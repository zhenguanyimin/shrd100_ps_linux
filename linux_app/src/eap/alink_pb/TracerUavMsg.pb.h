// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TracerUavMsg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_TracerUavMsg_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_TracerUavMsg_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_TracerUavMsg_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_TracerUavMsg_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_TracerUavMsg_2eproto;
namespace protobuf {
namespace traceruav {
class AngleInfoPB;
struct AngleInfoPBDefaultTypeInternal;
extern AngleInfoPBDefaultTypeInternal _AngleInfoPB_default_instance_;
class CtrlWorkModePB;
struct CtrlWorkModePBDefaultTypeInternal;
extern CtrlWorkModePBDefaultTypeInternal _CtrlWorkModePB_default_instance_;
class FlyStatusPB;
struct FlyStatusPBDefaultTypeInternal;
extern FlyStatusPBDefaultTypeInternal _FlyStatusPB_default_instance_;
class MeasureInfoPb;
struct MeasureInfoPbDefaultTypeInternal;
extern MeasureInfoPbDefaultTypeInternal _MeasureInfoPb_default_instance_;
class MeasureInfoPb_MeasureInfoData;
struct MeasureInfoPb_MeasureInfoDataDefaultTypeInternal;
extern MeasureInfoPb_MeasureInfoDataDefaultTypeInternal _MeasureInfoPb_MeasureInfoData_default_instance_;
class TracerUavMessagePB;
struct TracerUavMessagePBDefaultTypeInternal;
extern TracerUavMessagePBDefaultTypeInternal _TracerUavMessagePB_default_instance_;
}  // namespace traceruav
}  // namespace protobuf
PROTOBUF_NAMESPACE_OPEN
template<> ::protobuf::traceruav::AngleInfoPB* Arena::CreateMaybeMessage<::protobuf::traceruav::AngleInfoPB>(Arena*);
template<> ::protobuf::traceruav::CtrlWorkModePB* Arena::CreateMaybeMessage<::protobuf::traceruav::CtrlWorkModePB>(Arena*);
template<> ::protobuf::traceruav::FlyStatusPB* Arena::CreateMaybeMessage<::protobuf::traceruav::FlyStatusPB>(Arena*);
template<> ::protobuf::traceruav::MeasureInfoPb* Arena::CreateMaybeMessage<::protobuf::traceruav::MeasureInfoPb>(Arena*);
template<> ::protobuf::traceruav::MeasureInfoPb_MeasureInfoData* Arena::CreateMaybeMessage<::protobuf::traceruav::MeasureInfoPb_MeasureInfoData>(Arena*);
template<> ::protobuf::traceruav::TracerUavMessagePB* Arena::CreateMaybeMessage<::protobuf::traceruav::TracerUavMessagePB>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace protobuf {
namespace traceruav {

enum MessageType : int {
  TRACERUAVMSG_HEART_BEAT = 0,
  TRACERUAVMSG_WORK_MODE_TYPE = 1,
  TRACERUAVMSG_FLY_STATUS_TYPE = 2,
  TRACERUAVMSG_MEASURE_INFO_TYPE = 3,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = TRACERUAVMSG_HEART_BEAT;
constexpr MessageType MessageType_MAX = TRACERUAVMSG_MEASURE_INFO_TYPE;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class CtrlWorkModePB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuf.traceruav.CtrlWorkModePB) */ {
 public:
  inline CtrlWorkModePB() : CtrlWorkModePB(nullptr) {}
  ~CtrlWorkModePB() override;
  explicit constexpr CtrlWorkModePB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CtrlWorkModePB(const CtrlWorkModePB& from);
  CtrlWorkModePB(CtrlWorkModePB&& from) noexcept
    : CtrlWorkModePB() {
    *this = ::std::move(from);
  }

  inline CtrlWorkModePB& operator=(const CtrlWorkModePB& from) {
    CopyFrom(from);
    return *this;
  }
  inline CtrlWorkModePB& operator=(CtrlWorkModePB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CtrlWorkModePB& default_instance() {
    return *internal_default_instance();
  }
  static inline const CtrlWorkModePB* internal_default_instance() {
    return reinterpret_cast<const CtrlWorkModePB*>(
               &_CtrlWorkModePB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CtrlWorkModePB& a, CtrlWorkModePB& b) {
    a.Swap(&b);
  }
  inline void Swap(CtrlWorkModePB* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CtrlWorkModePB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CtrlWorkModePB* New() const final {
    return new CtrlWorkModePB();
  }

  CtrlWorkModePB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CtrlWorkModePB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CtrlWorkModePB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CtrlWorkModePB& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CtrlWorkModePB* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protobuf.traceruav.CtrlWorkModePB";
  }
  protected:
  explicit CtrlWorkModePB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkModeFieldNumber = 2,
    kDxNumFieldNumber = 3,
    kDxFreqFieldNumber = 4,
  };
  // uint32 workMode = 2;
  void clear_workmode();
  ::PROTOBUF_NAMESPACE_ID::uint32 workmode() const;
  void set_workmode(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_workmode() const;
  void _internal_set_workmode(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 dxNum = 3;
  void clear_dxnum();
  ::PROTOBUF_NAMESPACE_ID::uint32 dxnum() const;
  void set_dxnum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_dxnum() const;
  void _internal_set_dxnum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 dxFreq = 4;
  void clear_dxfreq();
  ::PROTOBUF_NAMESPACE_ID::uint32 dxfreq() const;
  void set_dxfreq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_dxfreq() const;
  void _internal_set_dxfreq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protobuf.traceruav.CtrlWorkModePB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 workmode_;
  ::PROTOBUF_NAMESPACE_ID::uint32 dxnum_;
  ::PROTOBUF_NAMESPACE_ID::uint32 dxfreq_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TracerUavMsg_2eproto;
};
// -------------------------------------------------------------------

class FlyStatusPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuf.traceruav.FlyStatusPB) */ {
 public:
  inline FlyStatusPB() : FlyStatusPB(nullptr) {}
  ~FlyStatusPB() override;
  explicit constexpr FlyStatusPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlyStatusPB(const FlyStatusPB& from);
  FlyStatusPB(FlyStatusPB&& from) noexcept
    : FlyStatusPB() {
    *this = ::std::move(from);
  }

  inline FlyStatusPB& operator=(const FlyStatusPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlyStatusPB& operator=(FlyStatusPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlyStatusPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlyStatusPB* internal_default_instance() {
    return reinterpret_cast<const FlyStatusPB*>(
               &_FlyStatusPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FlyStatusPB& a, FlyStatusPB& b) {
    a.Swap(&b);
  }
  inline void Swap(FlyStatusPB* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlyStatusPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FlyStatusPB* New() const final {
    return new FlyStatusPB();
  }

  FlyStatusPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FlyStatusPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlyStatusPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FlyStatusPB& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlyStatusPB* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protobuf.traceruav.FlyStatusPB";
  }
  protected:
  explicit FlyStatusPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYawFieldNumber = 2,
    kPitchFieldNumber = 3,
    kRollFieldNumber = 4,
    kWYFieldNumber = 5,
    kWPFieldNumber = 6,
    kWRFieldNumber = 7,
    kLongitudeFieldNumber = 8,
    kLatitudeFieldNumber = 9,
    kAltitudeFieldNumber = 10,
    kVXFieldNumber = 11,
    kVYFieldNumber = 12,
    kVZFieldNumber = 13,
  };
  // sint32 yaw = 2;
  void clear_yaw();
  ::PROTOBUF_NAMESPACE_ID::int32 yaw() const;
  void set_yaw(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_yaw() const;
  void _internal_set_yaw(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // sint32 pitch = 3;
  void clear_pitch();
  ::PROTOBUF_NAMESPACE_ID::int32 pitch() const;
  void set_pitch(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pitch() const;
  void _internal_set_pitch(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // sint32 roll = 4;
  void clear_roll();
  ::PROTOBUF_NAMESPACE_ID::int32 roll() const;
  void set_roll(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_roll() const;
  void _internal_set_roll(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // sint32 wY = 5;
  void clear_wy();
  ::PROTOBUF_NAMESPACE_ID::int32 wy() const;
  void set_wy(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_wy() const;
  void _internal_set_wy(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // sint32 wP = 6;
  void clear_wp();
  ::PROTOBUF_NAMESPACE_ID::int32 wp() const;
  void set_wp(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_wp() const;
  void _internal_set_wp(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // sint32 wR = 7;
  void clear_wr();
  ::PROTOBUF_NAMESPACE_ID::int32 wr() const;
  void set_wr(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_wr() const;
  void _internal_set_wr(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // sint64 longitude = 8;
  void clear_longitude();
  ::PROTOBUF_NAMESPACE_ID::int64 longitude() const;
  void set_longitude(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_longitude() const;
  void _internal_set_longitude(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // sint64 latitude = 9;
  void clear_latitude();
  ::PROTOBUF_NAMESPACE_ID::int64 latitude() const;
  void set_latitude(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_latitude() const;
  void _internal_set_latitude(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // sint64 altitude = 10;
  void clear_altitude();
  ::PROTOBUF_NAMESPACE_ID::int64 altitude() const;
  void set_altitude(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_altitude() const;
  void _internal_set_altitude(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // sint32 vX = 11;
  void clear_vx();
  ::PROTOBUF_NAMESPACE_ID::int32 vx() const;
  void set_vx(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vx() const;
  void _internal_set_vx(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // sint32 vY = 12;
  void clear_vy();
  ::PROTOBUF_NAMESPACE_ID::int32 vy() const;
  void set_vy(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vy() const;
  void _internal_set_vy(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // sint32 vZ = 13;
  void clear_vz();
  ::PROTOBUF_NAMESPACE_ID::int32 vz() const;
  void set_vz(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vz() const;
  void _internal_set_vz(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protobuf.traceruav.FlyStatusPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 yaw_;
  ::PROTOBUF_NAMESPACE_ID::int32 pitch_;
  ::PROTOBUF_NAMESPACE_ID::int32 roll_;
  ::PROTOBUF_NAMESPACE_ID::int32 wy_;
  ::PROTOBUF_NAMESPACE_ID::int32 wp_;
  ::PROTOBUF_NAMESPACE_ID::int32 wr_;
  ::PROTOBUF_NAMESPACE_ID::int64 longitude_;
  ::PROTOBUF_NAMESPACE_ID::int64 latitude_;
  ::PROTOBUF_NAMESPACE_ID::int64 altitude_;
  ::PROTOBUF_NAMESPACE_ID::int32 vx_;
  ::PROTOBUF_NAMESPACE_ID::int32 vy_;
  ::PROTOBUF_NAMESPACE_ID::int32 vz_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TracerUavMsg_2eproto;
};
// -------------------------------------------------------------------

class MeasureInfoPb_MeasureInfoData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuf.traceruav.MeasureInfoPb.MeasureInfoData) */ {
 public:
  inline MeasureInfoPb_MeasureInfoData() : MeasureInfoPb_MeasureInfoData(nullptr) {}
  ~MeasureInfoPb_MeasureInfoData() override;
  explicit constexpr MeasureInfoPb_MeasureInfoData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MeasureInfoPb_MeasureInfoData(const MeasureInfoPb_MeasureInfoData& from);
  MeasureInfoPb_MeasureInfoData(MeasureInfoPb_MeasureInfoData&& from) noexcept
    : MeasureInfoPb_MeasureInfoData() {
    *this = ::std::move(from);
  }

  inline MeasureInfoPb_MeasureInfoData& operator=(const MeasureInfoPb_MeasureInfoData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeasureInfoPb_MeasureInfoData& operator=(MeasureInfoPb_MeasureInfoData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeasureInfoPb_MeasureInfoData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MeasureInfoPb_MeasureInfoData* internal_default_instance() {
    return reinterpret_cast<const MeasureInfoPb_MeasureInfoData*>(
               &_MeasureInfoPb_MeasureInfoData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MeasureInfoPb_MeasureInfoData& a, MeasureInfoPb_MeasureInfoData& b) {
    a.Swap(&b);
  }
  inline void Swap(MeasureInfoPb_MeasureInfoData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeasureInfoPb_MeasureInfoData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MeasureInfoPb_MeasureInfoData* New() const final {
    return new MeasureInfoPb_MeasureInfoData();
  }

  MeasureInfoPb_MeasureInfoData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MeasureInfoPb_MeasureInfoData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MeasureInfoPb_MeasureInfoData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MeasureInfoPb_MeasureInfoData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MeasureInfoPb_MeasureInfoData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protobuf.traceruav.MeasureInfoPb.MeasureInfoData";
  }
  protected:
  explicit MeasureInfoPb_MeasureInfoData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTNumFieldNumber = 2,
    kTFreqFieldNumber = 3,
    kTAmpFieldNumber = 4,
    kTmFwFieldNumber = 5,
    kTmFyFieldNumber = 6,
    kTfFwFieldNumber = 7,
    kTfFyFieldNumber = 8,
  };
  // uint32 tNum = 2;
  void clear_tnum();
  ::PROTOBUF_NAMESPACE_ID::uint32 tnum() const;
  void set_tnum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_tnum() const;
  void _internal_set_tnum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 tFreq = 3;
  void clear_tfreq();
  ::PROTOBUF_NAMESPACE_ID::uint32 tfreq() const;
  void set_tfreq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_tfreq() const;
  void _internal_set_tfreq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 tAmp = 4;
  void clear_tamp();
  ::PROTOBUF_NAMESPACE_ID::uint32 tamp() const;
  void set_tamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_tamp() const;
  void _internal_set_tamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // sint32 tmFw = 5;
  void clear_tmfw();
  ::PROTOBUF_NAMESPACE_ID::int32 tmfw() const;
  void set_tmfw(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tmfw() const;
  void _internal_set_tmfw(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // sint32 tmFy = 6;
  void clear_tmfy();
  ::PROTOBUF_NAMESPACE_ID::int32 tmfy() const;
  void set_tmfy(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tmfy() const;
  void _internal_set_tmfy(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // sint32 tfFw = 7;
  void clear_tffw();
  ::PROTOBUF_NAMESPACE_ID::int32 tffw() const;
  void set_tffw(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tffw() const;
  void _internal_set_tffw(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // sint32 tfFy = 8;
  void clear_tffy();
  ::PROTOBUF_NAMESPACE_ID::int32 tffy() const;
  void set_tffy(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tffy() const;
  void _internal_set_tffy(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protobuf.traceruav.MeasureInfoPb.MeasureInfoData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tnum_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tfreq_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tamp_;
  ::PROTOBUF_NAMESPACE_ID::int32 tmfw_;
  ::PROTOBUF_NAMESPACE_ID::int32 tmfy_;
  ::PROTOBUF_NAMESPACE_ID::int32 tffw_;
  ::PROTOBUF_NAMESPACE_ID::int32 tffy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TracerUavMsg_2eproto;
};
// -------------------------------------------------------------------

class MeasureInfoPb final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuf.traceruav.MeasureInfoPb) */ {
 public:
  inline MeasureInfoPb() : MeasureInfoPb(nullptr) {}
  ~MeasureInfoPb() override;
  explicit constexpr MeasureInfoPb(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MeasureInfoPb(const MeasureInfoPb& from);
  MeasureInfoPb(MeasureInfoPb&& from) noexcept
    : MeasureInfoPb() {
    *this = ::std::move(from);
  }

  inline MeasureInfoPb& operator=(const MeasureInfoPb& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeasureInfoPb& operator=(MeasureInfoPb&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeasureInfoPb& default_instance() {
    return *internal_default_instance();
  }
  static inline const MeasureInfoPb* internal_default_instance() {
    return reinterpret_cast<const MeasureInfoPb*>(
               &_MeasureInfoPb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MeasureInfoPb& a, MeasureInfoPb& b) {
    a.Swap(&b);
  }
  inline void Swap(MeasureInfoPb* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeasureInfoPb* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MeasureInfoPb* New() const final {
    return new MeasureInfoPb();
  }

  MeasureInfoPb* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MeasureInfoPb>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MeasureInfoPb& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MeasureInfoPb& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MeasureInfoPb* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protobuf.traceruav.MeasureInfoPb";
  }
  protected:
  explicit MeasureInfoPb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MeasureInfoPb_MeasureInfoData MeasureInfoData;

  // accessors -------------------------------------------------------

  enum : int {
    kMeaInfoDataFieldNumber = 4,
    kWorkStatusFieldNumber = 2,
    kTarNumFieldNumber = 3,
  };
  // repeated .protobuf.traceruav.MeasureInfoPb.MeasureInfoData meaInfoData = 4;
  int meainfodata_size() const;
  private:
  int _internal_meainfodata_size() const;
  public:
  void clear_meainfodata();
  ::protobuf::traceruav::MeasureInfoPb_MeasureInfoData* mutable_meainfodata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuf::traceruav::MeasureInfoPb_MeasureInfoData >*
      mutable_meainfodata();
  private:
  const ::protobuf::traceruav::MeasureInfoPb_MeasureInfoData& _internal_meainfodata(int index) const;
  ::protobuf::traceruav::MeasureInfoPb_MeasureInfoData* _internal_add_meainfodata();
  public:
  const ::protobuf::traceruav::MeasureInfoPb_MeasureInfoData& meainfodata(int index) const;
  ::protobuf::traceruav::MeasureInfoPb_MeasureInfoData* add_meainfodata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuf::traceruav::MeasureInfoPb_MeasureInfoData >&
      meainfodata() const;

  // uint32 workStatus = 2;
  void clear_workstatus();
  ::PROTOBUF_NAMESPACE_ID::uint32 workstatus() const;
  void set_workstatus(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_workstatus() const;
  void _internal_set_workstatus(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 tarNum = 3;
  void clear_tarnum();
  ::PROTOBUF_NAMESPACE_ID::uint32 tarnum() const;
  void set_tarnum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_tarnum() const;
  void _internal_set_tarnum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protobuf.traceruav.MeasureInfoPb)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuf::traceruav::MeasureInfoPb_MeasureInfoData > meainfodata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 workstatus_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tarnum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TracerUavMsg_2eproto;
};
// -------------------------------------------------------------------

class TracerUavMessagePB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuf.traceruav.TracerUavMessagePB) */ {
 public:
  inline TracerUavMessagePB() : TracerUavMessagePB(nullptr) {}
  ~TracerUavMessagePB() override;
  explicit constexpr TracerUavMessagePB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TracerUavMessagePB(const TracerUavMessagePB& from);
  TracerUavMessagePB(TracerUavMessagePB&& from) noexcept
    : TracerUavMessagePB() {
    *this = ::std::move(from);
  }

  inline TracerUavMessagePB& operator=(const TracerUavMessagePB& from) {
    CopyFrom(from);
    return *this;
  }
  inline TracerUavMessagePB& operator=(TracerUavMessagePB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TracerUavMessagePB& default_instance() {
    return *internal_default_instance();
  }
  static inline const TracerUavMessagePB* internal_default_instance() {
    return reinterpret_cast<const TracerUavMessagePB*>(
               &_TracerUavMessagePB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TracerUavMessagePB& a, TracerUavMessagePB& b) {
    a.Swap(&b);
  }
  inline void Swap(TracerUavMessagePB* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TracerUavMessagePB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TracerUavMessagePB* New() const final {
    return new TracerUavMessagePB();
  }

  TracerUavMessagePB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TracerUavMessagePB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TracerUavMessagePB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TracerUavMessagePB& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TracerUavMessagePB* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protobuf.traceruav.TracerUavMessagePB";
  }
  protected:
  explicit TracerUavMessagePB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgChannelFieldNumber = 2,
    kMsgNameFieldNumber = 4,
    kWorkModeFieldNumber = 10,
    kFlyStatusFieldNumber = 11,
    kMeasureInfoFieldNumber = 12,
    kMsgTypeFieldNumber = 3,
    kMsgHandleFieldNumber = 5,
    kMsgSeqFieldNumber = 6,
  };
  // string msgChannel = 2;
  void clear_msgchannel();
  const std::string& msgchannel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msgchannel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msgchannel();
  PROTOBUF_MUST_USE_RESULT std::string* release_msgchannel();
  void set_allocated_msgchannel(std::string* msgchannel);
  private:
  const std::string& _internal_msgchannel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msgchannel(const std::string& value);
  std::string* _internal_mutable_msgchannel();
  public:

  // optional string msgName = 4;
  bool has_msgname() const;
  private:
  bool _internal_has_msgname() const;
  public:
  void clear_msgname();
  const std::string& msgname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msgname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msgname();
  PROTOBUF_MUST_USE_RESULT std::string* release_msgname();
  void set_allocated_msgname(std::string* msgname);
  private:
  const std::string& _internal_msgname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msgname(const std::string& value);
  std::string* _internal_mutable_msgname();
  public:

  // optional .protobuf.traceruav.CtrlWorkModePB workMode = 10;
  bool has_workmode() const;
  private:
  bool _internal_has_workmode() const;
  public:
  void clear_workmode();
  const ::protobuf::traceruav::CtrlWorkModePB& workmode() const;
  PROTOBUF_MUST_USE_RESULT ::protobuf::traceruav::CtrlWorkModePB* release_workmode();
  ::protobuf::traceruav::CtrlWorkModePB* mutable_workmode();
  void set_allocated_workmode(::protobuf::traceruav::CtrlWorkModePB* workmode);
  private:
  const ::protobuf::traceruav::CtrlWorkModePB& _internal_workmode() const;
  ::protobuf::traceruav::CtrlWorkModePB* _internal_mutable_workmode();
  public:
  void unsafe_arena_set_allocated_workmode(
      ::protobuf::traceruav::CtrlWorkModePB* workmode);
  ::protobuf::traceruav::CtrlWorkModePB* unsafe_arena_release_workmode();

  // optional .protobuf.traceruav.FlyStatusPB flyStatus = 11;
  bool has_flystatus() const;
  private:
  bool _internal_has_flystatus() const;
  public:
  void clear_flystatus();
  const ::protobuf::traceruav::FlyStatusPB& flystatus() const;
  PROTOBUF_MUST_USE_RESULT ::protobuf::traceruav::FlyStatusPB* release_flystatus();
  ::protobuf::traceruav::FlyStatusPB* mutable_flystatus();
  void set_allocated_flystatus(::protobuf::traceruav::FlyStatusPB* flystatus);
  private:
  const ::protobuf::traceruav::FlyStatusPB& _internal_flystatus() const;
  ::protobuf::traceruav::FlyStatusPB* _internal_mutable_flystatus();
  public:
  void unsafe_arena_set_allocated_flystatus(
      ::protobuf::traceruav::FlyStatusPB* flystatus);
  ::protobuf::traceruav::FlyStatusPB* unsafe_arena_release_flystatus();

  // optional .protobuf.traceruav.MeasureInfoPb measureInfo = 12;
  bool has_measureinfo() const;
  private:
  bool _internal_has_measureinfo() const;
  public:
  void clear_measureinfo();
  const ::protobuf::traceruav::MeasureInfoPb& measureinfo() const;
  PROTOBUF_MUST_USE_RESULT ::protobuf::traceruav::MeasureInfoPb* release_measureinfo();
  ::protobuf::traceruav::MeasureInfoPb* mutable_measureinfo();
  void set_allocated_measureinfo(::protobuf::traceruav::MeasureInfoPb* measureinfo);
  private:
  const ::protobuf::traceruav::MeasureInfoPb& _internal_measureinfo() const;
  ::protobuf::traceruav::MeasureInfoPb* _internal_mutable_measureinfo();
  public:
  void unsafe_arena_set_allocated_measureinfo(
      ::protobuf::traceruav::MeasureInfoPb* measureinfo);
  ::protobuf::traceruav::MeasureInfoPb* unsafe_arena_release_measureinfo();

  // .protobuf.traceruav.MessageType msgType = 3;
  void clear_msgtype();
  ::protobuf::traceruav::MessageType msgtype() const;
  void set_msgtype(::protobuf::traceruav::MessageType value);
  private:
  ::protobuf::traceruav::MessageType _internal_msgtype() const;
  void _internal_set_msgtype(::protobuf::traceruav::MessageType value);
  public:

  // uint32 msgHandle = 5;
  void clear_msghandle();
  ::PROTOBUF_NAMESPACE_ID::uint32 msghandle() const;
  void set_msghandle(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_msghandle() const;
  void _internal_set_msghandle(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 msgSeq = 6;
  void clear_msgseq();
  ::PROTOBUF_NAMESPACE_ID::uint32 msgseq() const;
  void set_msgseq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_msgseq() const;
  void _internal_set_msgseq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protobuf.traceruav.TracerUavMessagePB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msgchannel_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msgname_;
  ::protobuf::traceruav::CtrlWorkModePB* workmode_;
  ::protobuf::traceruav::FlyStatusPB* flystatus_;
  ::protobuf::traceruav::MeasureInfoPb* measureinfo_;
  int msgtype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 msghandle_;
  ::PROTOBUF_NAMESPACE_ID::uint32 msgseq_;
  friend struct ::TableStruct_TracerUavMsg_2eproto;
};
// -------------------------------------------------------------------

class AngleInfoPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuf.traceruav.AngleInfoPB) */ {
 public:
  inline AngleInfoPB() : AngleInfoPB(nullptr) {}
  ~AngleInfoPB() override;
  explicit constexpr AngleInfoPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AngleInfoPB(const AngleInfoPB& from);
  AngleInfoPB(AngleInfoPB&& from) noexcept
    : AngleInfoPB() {
    *this = ::std::move(from);
  }

  inline AngleInfoPB& operator=(const AngleInfoPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline AngleInfoPB& operator=(AngleInfoPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AngleInfoPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const AngleInfoPB* internal_default_instance() {
    return reinterpret_cast<const AngleInfoPB*>(
               &_AngleInfoPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AngleInfoPB& a, AngleInfoPB& b) {
    a.Swap(&b);
  }
  inline void Swap(AngleInfoPB* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AngleInfoPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AngleInfoPB* New() const final {
    return new AngleInfoPB();
  }

  AngleInfoPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AngleInfoPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AngleInfoPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AngleInfoPB& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AngleInfoPB* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protobuf.traceruav.AngleInfoPB";
  }
  protected:
  explicit AngleInfoPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRollFieldNumber = 2,
    kPitchFieldNumber = 3,
    kYawFieldNumber = 4,
  };
  // float roll = 2;
  void clear_roll();
  float roll() const;
  void set_roll(float value);
  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);
  public:

  // float pitch = 3;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // float yaw = 4;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // @@protoc_insertion_point(class_scope:protobuf.traceruav.AngleInfoPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float roll_;
  float pitch_;
  float yaw_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TracerUavMsg_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CtrlWorkModePB

// uint32 workMode = 2;
inline void CtrlWorkModePB::clear_workmode() {
  workmode_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CtrlWorkModePB::_internal_workmode() const {
  return workmode_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CtrlWorkModePB::workmode() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.CtrlWorkModePB.workMode)
  return _internal_workmode();
}
inline void CtrlWorkModePB::_internal_set_workmode(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  workmode_ = value;
}
inline void CtrlWorkModePB::set_workmode(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_workmode(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.CtrlWorkModePB.workMode)
}

// uint32 dxNum = 3;
inline void CtrlWorkModePB::clear_dxnum() {
  dxnum_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CtrlWorkModePB::_internal_dxnum() const {
  return dxnum_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CtrlWorkModePB::dxnum() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.CtrlWorkModePB.dxNum)
  return _internal_dxnum();
}
inline void CtrlWorkModePB::_internal_set_dxnum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  dxnum_ = value;
}
inline void CtrlWorkModePB::set_dxnum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_dxnum(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.CtrlWorkModePB.dxNum)
}

// uint32 dxFreq = 4;
inline void CtrlWorkModePB::clear_dxfreq() {
  dxfreq_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CtrlWorkModePB::_internal_dxfreq() const {
  return dxfreq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CtrlWorkModePB::dxfreq() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.CtrlWorkModePB.dxFreq)
  return _internal_dxfreq();
}
inline void CtrlWorkModePB::_internal_set_dxfreq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  dxfreq_ = value;
}
inline void CtrlWorkModePB::set_dxfreq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_dxfreq(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.CtrlWorkModePB.dxFreq)
}

// -------------------------------------------------------------------

// FlyStatusPB

// sint32 yaw = 2;
inline void FlyStatusPB::clear_yaw() {
  yaw_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlyStatusPB::_internal_yaw() const {
  return yaw_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlyStatusPB::yaw() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.FlyStatusPB.yaw)
  return _internal_yaw();
}
inline void FlyStatusPB::_internal_set_yaw(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  yaw_ = value;
}
inline void FlyStatusPB::set_yaw(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.FlyStatusPB.yaw)
}

// sint32 pitch = 3;
inline void FlyStatusPB::clear_pitch() {
  pitch_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlyStatusPB::_internal_pitch() const {
  return pitch_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlyStatusPB::pitch() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.FlyStatusPB.pitch)
  return _internal_pitch();
}
inline void FlyStatusPB::_internal_set_pitch(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pitch_ = value;
}
inline void FlyStatusPB::set_pitch(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.FlyStatusPB.pitch)
}

// sint32 roll = 4;
inline void FlyStatusPB::clear_roll() {
  roll_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlyStatusPB::_internal_roll() const {
  return roll_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlyStatusPB::roll() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.FlyStatusPB.roll)
  return _internal_roll();
}
inline void FlyStatusPB::_internal_set_roll(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  roll_ = value;
}
inline void FlyStatusPB::set_roll(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.FlyStatusPB.roll)
}

// sint32 wY = 5;
inline void FlyStatusPB::clear_wy() {
  wy_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlyStatusPB::_internal_wy() const {
  return wy_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlyStatusPB::wy() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.FlyStatusPB.wY)
  return _internal_wy();
}
inline void FlyStatusPB::_internal_set_wy(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  wy_ = value;
}
inline void FlyStatusPB::set_wy(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_wy(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.FlyStatusPB.wY)
}

// sint32 wP = 6;
inline void FlyStatusPB::clear_wp() {
  wp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlyStatusPB::_internal_wp() const {
  return wp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlyStatusPB::wp() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.FlyStatusPB.wP)
  return _internal_wp();
}
inline void FlyStatusPB::_internal_set_wp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  wp_ = value;
}
inline void FlyStatusPB::set_wp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_wp(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.FlyStatusPB.wP)
}

// sint32 wR = 7;
inline void FlyStatusPB::clear_wr() {
  wr_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlyStatusPB::_internal_wr() const {
  return wr_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlyStatusPB::wr() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.FlyStatusPB.wR)
  return _internal_wr();
}
inline void FlyStatusPB::_internal_set_wr(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  wr_ = value;
}
inline void FlyStatusPB::set_wr(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_wr(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.FlyStatusPB.wR)
}

// sint64 longitude = 8;
inline void FlyStatusPB::clear_longitude() {
  longitude_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FlyStatusPB::_internal_longitude() const {
  return longitude_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FlyStatusPB::longitude() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.FlyStatusPB.longitude)
  return _internal_longitude();
}
inline void FlyStatusPB::_internal_set_longitude(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  longitude_ = value;
}
inline void FlyStatusPB::set_longitude(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.FlyStatusPB.longitude)
}

// sint64 latitude = 9;
inline void FlyStatusPB::clear_latitude() {
  latitude_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FlyStatusPB::_internal_latitude() const {
  return latitude_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FlyStatusPB::latitude() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.FlyStatusPB.latitude)
  return _internal_latitude();
}
inline void FlyStatusPB::_internal_set_latitude(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  latitude_ = value;
}
inline void FlyStatusPB::set_latitude(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.FlyStatusPB.latitude)
}

// sint64 altitude = 10;
inline void FlyStatusPB::clear_altitude() {
  altitude_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FlyStatusPB::_internal_altitude() const {
  return altitude_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FlyStatusPB::altitude() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.FlyStatusPB.altitude)
  return _internal_altitude();
}
inline void FlyStatusPB::_internal_set_altitude(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  altitude_ = value;
}
inline void FlyStatusPB::set_altitude(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_altitude(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.FlyStatusPB.altitude)
}

// sint32 vX = 11;
inline void FlyStatusPB::clear_vx() {
  vx_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlyStatusPB::_internal_vx() const {
  return vx_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlyStatusPB::vx() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.FlyStatusPB.vX)
  return _internal_vx();
}
inline void FlyStatusPB::_internal_set_vx(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  vx_ = value;
}
inline void FlyStatusPB::set_vx(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vx(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.FlyStatusPB.vX)
}

// sint32 vY = 12;
inline void FlyStatusPB::clear_vy() {
  vy_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlyStatusPB::_internal_vy() const {
  return vy_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlyStatusPB::vy() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.FlyStatusPB.vY)
  return _internal_vy();
}
inline void FlyStatusPB::_internal_set_vy(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  vy_ = value;
}
inline void FlyStatusPB::set_vy(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vy(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.FlyStatusPB.vY)
}

// sint32 vZ = 13;
inline void FlyStatusPB::clear_vz() {
  vz_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlyStatusPB::_internal_vz() const {
  return vz_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlyStatusPB::vz() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.FlyStatusPB.vZ)
  return _internal_vz();
}
inline void FlyStatusPB::_internal_set_vz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  vz_ = value;
}
inline void FlyStatusPB::set_vz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vz(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.FlyStatusPB.vZ)
}

// -------------------------------------------------------------------

// MeasureInfoPb_MeasureInfoData

// uint32 tNum = 2;
inline void MeasureInfoPb_MeasureInfoData::clear_tnum() {
  tnum_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MeasureInfoPb_MeasureInfoData::_internal_tnum() const {
  return tnum_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MeasureInfoPb_MeasureInfoData::tnum() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.MeasureInfoPb.MeasureInfoData.tNum)
  return _internal_tnum();
}
inline void MeasureInfoPb_MeasureInfoData::_internal_set_tnum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  tnum_ = value;
}
inline void MeasureInfoPb_MeasureInfoData::set_tnum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_tnum(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.MeasureInfoPb.MeasureInfoData.tNum)
}

// uint32 tFreq = 3;
inline void MeasureInfoPb_MeasureInfoData::clear_tfreq() {
  tfreq_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MeasureInfoPb_MeasureInfoData::_internal_tfreq() const {
  return tfreq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MeasureInfoPb_MeasureInfoData::tfreq() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.MeasureInfoPb.MeasureInfoData.tFreq)
  return _internal_tfreq();
}
inline void MeasureInfoPb_MeasureInfoData::_internal_set_tfreq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  tfreq_ = value;
}
inline void MeasureInfoPb_MeasureInfoData::set_tfreq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_tfreq(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.MeasureInfoPb.MeasureInfoData.tFreq)
}

// uint32 tAmp = 4;
inline void MeasureInfoPb_MeasureInfoData::clear_tamp() {
  tamp_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MeasureInfoPb_MeasureInfoData::_internal_tamp() const {
  return tamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MeasureInfoPb_MeasureInfoData::tamp() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.MeasureInfoPb.MeasureInfoData.tAmp)
  return _internal_tamp();
}
inline void MeasureInfoPb_MeasureInfoData::_internal_set_tamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  tamp_ = value;
}
inline void MeasureInfoPb_MeasureInfoData::set_tamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_tamp(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.MeasureInfoPb.MeasureInfoData.tAmp)
}

// sint32 tmFw = 5;
inline void MeasureInfoPb_MeasureInfoData::clear_tmfw() {
  tmfw_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MeasureInfoPb_MeasureInfoData::_internal_tmfw() const {
  return tmfw_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MeasureInfoPb_MeasureInfoData::tmfw() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.MeasureInfoPb.MeasureInfoData.tmFw)
  return _internal_tmfw();
}
inline void MeasureInfoPb_MeasureInfoData::_internal_set_tmfw(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  tmfw_ = value;
}
inline void MeasureInfoPb_MeasureInfoData::set_tmfw(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tmfw(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.MeasureInfoPb.MeasureInfoData.tmFw)
}

// sint32 tmFy = 6;
inline void MeasureInfoPb_MeasureInfoData::clear_tmfy() {
  tmfy_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MeasureInfoPb_MeasureInfoData::_internal_tmfy() const {
  return tmfy_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MeasureInfoPb_MeasureInfoData::tmfy() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.MeasureInfoPb.MeasureInfoData.tmFy)
  return _internal_tmfy();
}
inline void MeasureInfoPb_MeasureInfoData::_internal_set_tmfy(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  tmfy_ = value;
}
inline void MeasureInfoPb_MeasureInfoData::set_tmfy(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tmfy(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.MeasureInfoPb.MeasureInfoData.tmFy)
}

// sint32 tfFw = 7;
inline void MeasureInfoPb_MeasureInfoData::clear_tffw() {
  tffw_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MeasureInfoPb_MeasureInfoData::_internal_tffw() const {
  return tffw_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MeasureInfoPb_MeasureInfoData::tffw() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.MeasureInfoPb.MeasureInfoData.tfFw)
  return _internal_tffw();
}
inline void MeasureInfoPb_MeasureInfoData::_internal_set_tffw(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  tffw_ = value;
}
inline void MeasureInfoPb_MeasureInfoData::set_tffw(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tffw(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.MeasureInfoPb.MeasureInfoData.tfFw)
}

// sint32 tfFy = 8;
inline void MeasureInfoPb_MeasureInfoData::clear_tffy() {
  tffy_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MeasureInfoPb_MeasureInfoData::_internal_tffy() const {
  return tffy_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MeasureInfoPb_MeasureInfoData::tffy() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.MeasureInfoPb.MeasureInfoData.tfFy)
  return _internal_tffy();
}
inline void MeasureInfoPb_MeasureInfoData::_internal_set_tffy(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  tffy_ = value;
}
inline void MeasureInfoPb_MeasureInfoData::set_tffy(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tffy(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.MeasureInfoPb.MeasureInfoData.tfFy)
}

// -------------------------------------------------------------------

// MeasureInfoPb

// uint32 workStatus = 2;
inline void MeasureInfoPb::clear_workstatus() {
  workstatus_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MeasureInfoPb::_internal_workstatus() const {
  return workstatus_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MeasureInfoPb::workstatus() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.MeasureInfoPb.workStatus)
  return _internal_workstatus();
}
inline void MeasureInfoPb::_internal_set_workstatus(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  workstatus_ = value;
}
inline void MeasureInfoPb::set_workstatus(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_workstatus(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.MeasureInfoPb.workStatus)
}

// uint32 tarNum = 3;
inline void MeasureInfoPb::clear_tarnum() {
  tarnum_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MeasureInfoPb::_internal_tarnum() const {
  return tarnum_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MeasureInfoPb::tarnum() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.MeasureInfoPb.tarNum)
  return _internal_tarnum();
}
inline void MeasureInfoPb::_internal_set_tarnum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  tarnum_ = value;
}
inline void MeasureInfoPb::set_tarnum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_tarnum(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.MeasureInfoPb.tarNum)
}

// repeated .protobuf.traceruav.MeasureInfoPb.MeasureInfoData meaInfoData = 4;
inline int MeasureInfoPb::_internal_meainfodata_size() const {
  return meainfodata_.size();
}
inline int MeasureInfoPb::meainfodata_size() const {
  return _internal_meainfodata_size();
}
inline void MeasureInfoPb::clear_meainfodata() {
  meainfodata_.Clear();
}
inline ::protobuf::traceruav::MeasureInfoPb_MeasureInfoData* MeasureInfoPb::mutable_meainfodata(int index) {
  // @@protoc_insertion_point(field_mutable:protobuf.traceruav.MeasureInfoPb.meaInfoData)
  return meainfodata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuf::traceruav::MeasureInfoPb_MeasureInfoData >*
MeasureInfoPb::mutable_meainfodata() {
  // @@protoc_insertion_point(field_mutable_list:protobuf.traceruav.MeasureInfoPb.meaInfoData)
  return &meainfodata_;
}
inline const ::protobuf::traceruav::MeasureInfoPb_MeasureInfoData& MeasureInfoPb::_internal_meainfodata(int index) const {
  return meainfodata_.Get(index);
}
inline const ::protobuf::traceruav::MeasureInfoPb_MeasureInfoData& MeasureInfoPb::meainfodata(int index) const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.MeasureInfoPb.meaInfoData)
  return _internal_meainfodata(index);
}
inline ::protobuf::traceruav::MeasureInfoPb_MeasureInfoData* MeasureInfoPb::_internal_add_meainfodata() {
  return meainfodata_.Add();
}
inline ::protobuf::traceruav::MeasureInfoPb_MeasureInfoData* MeasureInfoPb::add_meainfodata() {
  ::protobuf::traceruav::MeasureInfoPb_MeasureInfoData* _add = _internal_add_meainfodata();
  // @@protoc_insertion_point(field_add:protobuf.traceruav.MeasureInfoPb.meaInfoData)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuf::traceruav::MeasureInfoPb_MeasureInfoData >&
MeasureInfoPb::meainfodata() const {
  // @@protoc_insertion_point(field_list:protobuf.traceruav.MeasureInfoPb.meaInfoData)
  return meainfodata_;
}

// -------------------------------------------------------------------

// TracerUavMessagePB

// string msgChannel = 2;
inline void TracerUavMessagePB::clear_msgchannel() {
  msgchannel_.ClearToEmpty();
}
inline const std::string& TracerUavMessagePB::msgchannel() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.TracerUavMessagePB.msgChannel)
  return _internal_msgchannel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TracerUavMessagePB::set_msgchannel(ArgT0&& arg0, ArgT... args) {
 
 msgchannel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.traceruav.TracerUavMessagePB.msgChannel)
}
inline std::string* TracerUavMessagePB::mutable_msgchannel() {
  std::string* _s = _internal_mutable_msgchannel();
  // @@protoc_insertion_point(field_mutable:protobuf.traceruav.TracerUavMessagePB.msgChannel)
  return _s;
}
inline const std::string& TracerUavMessagePB::_internal_msgchannel() const {
  return msgchannel_.Get();
}
inline void TracerUavMessagePB::_internal_set_msgchannel(const std::string& value) {
  
  msgchannel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TracerUavMessagePB::_internal_mutable_msgchannel() {
  
  return msgchannel_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TracerUavMessagePB::release_msgchannel() {
  // @@protoc_insertion_point(field_release:protobuf.traceruav.TracerUavMessagePB.msgChannel)
  return msgchannel_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TracerUavMessagePB::set_allocated_msgchannel(std::string* msgchannel) {
  if (msgchannel != nullptr) {
    
  } else {
    
  }
  msgchannel_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msgchannel,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protobuf.traceruav.TracerUavMessagePB.msgChannel)
}

// .protobuf.traceruav.MessageType msgType = 3;
inline void TracerUavMessagePB::clear_msgtype() {
  msgtype_ = 0;
}
inline ::protobuf::traceruav::MessageType TracerUavMessagePB::_internal_msgtype() const {
  return static_cast< ::protobuf::traceruav::MessageType >(msgtype_);
}
inline ::protobuf::traceruav::MessageType TracerUavMessagePB::msgtype() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.TracerUavMessagePB.msgType)
  return _internal_msgtype();
}
inline void TracerUavMessagePB::_internal_set_msgtype(::protobuf::traceruav::MessageType value) {
  
  msgtype_ = value;
}
inline void TracerUavMessagePB::set_msgtype(::protobuf::traceruav::MessageType value) {
  _internal_set_msgtype(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.TracerUavMessagePB.msgType)
}

// optional string msgName = 4;
inline bool TracerUavMessagePB::_internal_has_msgname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TracerUavMessagePB::has_msgname() const {
  return _internal_has_msgname();
}
inline void TracerUavMessagePB::clear_msgname() {
  msgname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TracerUavMessagePB::msgname() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.TracerUavMessagePB.msgName)
  return _internal_msgname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TracerUavMessagePB::set_msgname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 msgname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.traceruav.TracerUavMessagePB.msgName)
}
inline std::string* TracerUavMessagePB::mutable_msgname() {
  std::string* _s = _internal_mutable_msgname();
  // @@protoc_insertion_point(field_mutable:protobuf.traceruav.TracerUavMessagePB.msgName)
  return _s;
}
inline const std::string& TracerUavMessagePB::_internal_msgname() const {
  return msgname_.Get();
}
inline void TracerUavMessagePB::_internal_set_msgname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  msgname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TracerUavMessagePB::_internal_mutable_msgname() {
  _has_bits_[0] |= 0x00000001u;
  return msgname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TracerUavMessagePB::release_msgname() {
  // @@protoc_insertion_point(field_release:protobuf.traceruav.TracerUavMessagePB.msgName)
  if (!_internal_has_msgname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return msgname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TracerUavMessagePB::set_allocated_msgname(std::string* msgname) {
  if (msgname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  msgname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msgname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protobuf.traceruav.TracerUavMessagePB.msgName)
}

// uint32 msgHandle = 5;
inline void TracerUavMessagePB::clear_msghandle() {
  msghandle_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TracerUavMessagePB::_internal_msghandle() const {
  return msghandle_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TracerUavMessagePB::msghandle() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.TracerUavMessagePB.msgHandle)
  return _internal_msghandle();
}
inline void TracerUavMessagePB::_internal_set_msghandle(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  msghandle_ = value;
}
inline void TracerUavMessagePB::set_msghandle(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_msghandle(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.TracerUavMessagePB.msgHandle)
}

// uint32 msgSeq = 6;
inline void TracerUavMessagePB::clear_msgseq() {
  msgseq_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TracerUavMessagePB::_internal_msgseq() const {
  return msgseq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TracerUavMessagePB::msgseq() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.TracerUavMessagePB.msgSeq)
  return _internal_msgseq();
}
inline void TracerUavMessagePB::_internal_set_msgseq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  msgseq_ = value;
}
inline void TracerUavMessagePB::set_msgseq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_msgseq(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.TracerUavMessagePB.msgSeq)
}

// optional .protobuf.traceruav.CtrlWorkModePB workMode = 10;
inline bool TracerUavMessagePB::_internal_has_workmode() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || workmode_ != nullptr);
  return value;
}
inline bool TracerUavMessagePB::has_workmode() const {
  return _internal_has_workmode();
}
inline void TracerUavMessagePB::clear_workmode() {
  if (workmode_ != nullptr) workmode_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::protobuf::traceruav::CtrlWorkModePB& TracerUavMessagePB::_internal_workmode() const {
  const ::protobuf::traceruav::CtrlWorkModePB* p = workmode_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::traceruav::CtrlWorkModePB&>(
      ::protobuf::traceruav::_CtrlWorkModePB_default_instance_);
}
inline const ::protobuf::traceruav::CtrlWorkModePB& TracerUavMessagePB::workmode() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.TracerUavMessagePB.workMode)
  return _internal_workmode();
}
inline void TracerUavMessagePB::unsafe_arena_set_allocated_workmode(
    ::protobuf::traceruav::CtrlWorkModePB* workmode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(workmode_);
  }
  workmode_ = workmode;
  if (workmode) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.traceruav.TracerUavMessagePB.workMode)
}
inline ::protobuf::traceruav::CtrlWorkModePB* TracerUavMessagePB::release_workmode() {
  _has_bits_[0] &= ~0x00000002u;
  ::protobuf::traceruav::CtrlWorkModePB* temp = workmode_;
  workmode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protobuf::traceruav::CtrlWorkModePB* TracerUavMessagePB::unsafe_arena_release_workmode() {
  // @@protoc_insertion_point(field_release:protobuf.traceruav.TracerUavMessagePB.workMode)
  _has_bits_[0] &= ~0x00000002u;
  ::protobuf::traceruav::CtrlWorkModePB* temp = workmode_;
  workmode_ = nullptr;
  return temp;
}
inline ::protobuf::traceruav::CtrlWorkModePB* TracerUavMessagePB::_internal_mutable_workmode() {
  _has_bits_[0] |= 0x00000002u;
  if (workmode_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::traceruav::CtrlWorkModePB>(GetArenaForAllocation());
    workmode_ = p;
  }
  return workmode_;
}
inline ::protobuf::traceruav::CtrlWorkModePB* TracerUavMessagePB::mutable_workmode() {
  ::protobuf::traceruav::CtrlWorkModePB* _msg = _internal_mutable_workmode();
  // @@protoc_insertion_point(field_mutable:protobuf.traceruav.TracerUavMessagePB.workMode)
  return _msg;
}
inline void TracerUavMessagePB::set_allocated_workmode(::protobuf::traceruav::CtrlWorkModePB* workmode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete workmode_;
  }
  if (workmode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protobuf::traceruav::CtrlWorkModePB>::GetOwningArena(workmode);
    if (message_arena != submessage_arena) {
      workmode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, workmode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  workmode_ = workmode;
  // @@protoc_insertion_point(field_set_allocated:protobuf.traceruav.TracerUavMessagePB.workMode)
}

// optional .protobuf.traceruav.FlyStatusPB flyStatus = 11;
inline bool TracerUavMessagePB::_internal_has_flystatus() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || flystatus_ != nullptr);
  return value;
}
inline bool TracerUavMessagePB::has_flystatus() const {
  return _internal_has_flystatus();
}
inline void TracerUavMessagePB::clear_flystatus() {
  if (flystatus_ != nullptr) flystatus_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::protobuf::traceruav::FlyStatusPB& TracerUavMessagePB::_internal_flystatus() const {
  const ::protobuf::traceruav::FlyStatusPB* p = flystatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::traceruav::FlyStatusPB&>(
      ::protobuf::traceruav::_FlyStatusPB_default_instance_);
}
inline const ::protobuf::traceruav::FlyStatusPB& TracerUavMessagePB::flystatus() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.TracerUavMessagePB.flyStatus)
  return _internal_flystatus();
}
inline void TracerUavMessagePB::unsafe_arena_set_allocated_flystatus(
    ::protobuf::traceruav::FlyStatusPB* flystatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flystatus_);
  }
  flystatus_ = flystatus;
  if (flystatus) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.traceruav.TracerUavMessagePB.flyStatus)
}
inline ::protobuf::traceruav::FlyStatusPB* TracerUavMessagePB::release_flystatus() {
  _has_bits_[0] &= ~0x00000004u;
  ::protobuf::traceruav::FlyStatusPB* temp = flystatus_;
  flystatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protobuf::traceruav::FlyStatusPB* TracerUavMessagePB::unsafe_arena_release_flystatus() {
  // @@protoc_insertion_point(field_release:protobuf.traceruav.TracerUavMessagePB.flyStatus)
  _has_bits_[0] &= ~0x00000004u;
  ::protobuf::traceruav::FlyStatusPB* temp = flystatus_;
  flystatus_ = nullptr;
  return temp;
}
inline ::protobuf::traceruav::FlyStatusPB* TracerUavMessagePB::_internal_mutable_flystatus() {
  _has_bits_[0] |= 0x00000004u;
  if (flystatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::traceruav::FlyStatusPB>(GetArenaForAllocation());
    flystatus_ = p;
  }
  return flystatus_;
}
inline ::protobuf::traceruav::FlyStatusPB* TracerUavMessagePB::mutable_flystatus() {
  ::protobuf::traceruav::FlyStatusPB* _msg = _internal_mutable_flystatus();
  // @@protoc_insertion_point(field_mutable:protobuf.traceruav.TracerUavMessagePB.flyStatus)
  return _msg;
}
inline void TracerUavMessagePB::set_allocated_flystatus(::protobuf::traceruav::FlyStatusPB* flystatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete flystatus_;
  }
  if (flystatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protobuf::traceruav::FlyStatusPB>::GetOwningArena(flystatus);
    if (message_arena != submessage_arena) {
      flystatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flystatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  flystatus_ = flystatus;
  // @@protoc_insertion_point(field_set_allocated:protobuf.traceruav.TracerUavMessagePB.flyStatus)
}

// optional .protobuf.traceruav.MeasureInfoPb measureInfo = 12;
inline bool TracerUavMessagePB::_internal_has_measureinfo() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || measureinfo_ != nullptr);
  return value;
}
inline bool TracerUavMessagePB::has_measureinfo() const {
  return _internal_has_measureinfo();
}
inline void TracerUavMessagePB::clear_measureinfo() {
  if (measureinfo_ != nullptr) measureinfo_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::protobuf::traceruav::MeasureInfoPb& TracerUavMessagePB::_internal_measureinfo() const {
  const ::protobuf::traceruav::MeasureInfoPb* p = measureinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::traceruav::MeasureInfoPb&>(
      ::protobuf::traceruav::_MeasureInfoPb_default_instance_);
}
inline const ::protobuf::traceruav::MeasureInfoPb& TracerUavMessagePB::measureinfo() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.TracerUavMessagePB.measureInfo)
  return _internal_measureinfo();
}
inline void TracerUavMessagePB::unsafe_arena_set_allocated_measureinfo(
    ::protobuf::traceruav::MeasureInfoPb* measureinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(measureinfo_);
  }
  measureinfo_ = measureinfo;
  if (measureinfo) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.traceruav.TracerUavMessagePB.measureInfo)
}
inline ::protobuf::traceruav::MeasureInfoPb* TracerUavMessagePB::release_measureinfo() {
  _has_bits_[0] &= ~0x00000008u;
  ::protobuf::traceruav::MeasureInfoPb* temp = measureinfo_;
  measureinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protobuf::traceruav::MeasureInfoPb* TracerUavMessagePB::unsafe_arena_release_measureinfo() {
  // @@protoc_insertion_point(field_release:protobuf.traceruav.TracerUavMessagePB.measureInfo)
  _has_bits_[0] &= ~0x00000008u;
  ::protobuf::traceruav::MeasureInfoPb* temp = measureinfo_;
  measureinfo_ = nullptr;
  return temp;
}
inline ::protobuf::traceruav::MeasureInfoPb* TracerUavMessagePB::_internal_mutable_measureinfo() {
  _has_bits_[0] |= 0x00000008u;
  if (measureinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::traceruav::MeasureInfoPb>(GetArenaForAllocation());
    measureinfo_ = p;
  }
  return measureinfo_;
}
inline ::protobuf::traceruav::MeasureInfoPb* TracerUavMessagePB::mutable_measureinfo() {
  ::protobuf::traceruav::MeasureInfoPb* _msg = _internal_mutable_measureinfo();
  // @@protoc_insertion_point(field_mutable:protobuf.traceruav.TracerUavMessagePB.measureInfo)
  return _msg;
}
inline void TracerUavMessagePB::set_allocated_measureinfo(::protobuf::traceruav::MeasureInfoPb* measureinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete measureinfo_;
  }
  if (measureinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protobuf::traceruav::MeasureInfoPb>::GetOwningArena(measureinfo);
    if (message_arena != submessage_arena) {
      measureinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, measureinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  measureinfo_ = measureinfo;
  // @@protoc_insertion_point(field_set_allocated:protobuf.traceruav.TracerUavMessagePB.measureInfo)
}

// -------------------------------------------------------------------

// AngleInfoPB

// float roll = 2;
inline void AngleInfoPB::clear_roll() {
  roll_ = 0;
}
inline float AngleInfoPB::_internal_roll() const {
  return roll_;
}
inline float AngleInfoPB::roll() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.AngleInfoPB.roll)
  return _internal_roll();
}
inline void AngleInfoPB::_internal_set_roll(float value) {
  
  roll_ = value;
}
inline void AngleInfoPB::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.AngleInfoPB.roll)
}

// float pitch = 3;
inline void AngleInfoPB::clear_pitch() {
  pitch_ = 0;
}
inline float AngleInfoPB::_internal_pitch() const {
  return pitch_;
}
inline float AngleInfoPB::pitch() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.AngleInfoPB.pitch)
  return _internal_pitch();
}
inline void AngleInfoPB::_internal_set_pitch(float value) {
  
  pitch_ = value;
}
inline void AngleInfoPB::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.AngleInfoPB.pitch)
}

// float yaw = 4;
inline void AngleInfoPB::clear_yaw() {
  yaw_ = 0;
}
inline float AngleInfoPB::_internal_yaw() const {
  return yaw_;
}
inline float AngleInfoPB::yaw() const {
  // @@protoc_insertion_point(field_get:protobuf.traceruav.AngleInfoPB.yaw)
  return _internal_yaw();
}
inline void AngleInfoPB::_internal_set_yaw(float value) {
  
  yaw_ = value;
}
inline void AngleInfoPB::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:protobuf.traceruav.AngleInfoPB.yaw)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace traceruav
}  // namespace protobuf

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::protobuf::traceruav::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::traceruav::MessageType>() {
  return ::protobuf::traceruav::MessageType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_TracerUavMsg_2eproto
