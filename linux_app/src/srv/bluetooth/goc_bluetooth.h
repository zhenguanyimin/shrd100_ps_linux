/********************************************************
 * Do NOT edit this file. It is generated by AT parser. *
********************************************************/


#ifndef _GOC_BLUETOOTH_H__
#define _GOC_BLUETOOTH_H__

#ifdef __cplusplus
	extern "C" {
#endif

#include "bluetooth.h"

enum{
	PROFILE_ID_HFP = 3,
	PROFILE_ID_A2DP,
	PROFILE_ID_AVRCP,
};

typedef void (*state_changed_callback)(uint8_t state);
typedef void (*bt_version_callback)(char * version);
typedef void (*device_found_callback)(bt_bdaddr_t address, uint8_t type_of_device, int class_of_device, uint8_t rssi, char * name, uint8_t num_svc, uint16_t *svc);
typedef void (*discovery_state_changed_callback)(uint8_t state);
typedef void (*pin_request_callback)(bt_bdaddr_t address, int class_of_device, uint8_t min_16_digit, char * name);
typedef void (*ssp_request_callback)(bt_bdaddr_t address, int class_of_device, uint8_t pairing_variant, int passkey, char * name);
typedef void (*bond_state_changed_callback)(uint8_t status, bt_bdaddr_t address, uint8_t state);
typedef void (*acl_state_changed_callback)(uint8_t status, bt_bdaddr_t address, uint8_t state);
typedef void (*app_gap_started_callback)(uint16_t len,uint8_t * data);
typedef void (*connection_auth_req_callback)(bt_bdaddr_t address,uint8_t profile_id);
typedef void (*le_rx_test_callback)(uint8_t status);
typedef void (*le_tx_test_callback)(uint8_t status);
typedef void (*le_test_end_callback)(uint8_t status, uint16_t number_of_packets);

typedef struct tag_bluetooth_callback {
	state_changed_callback state_changed_cb;
	bt_version_callback bt_version_cb;
	device_found_callback device_found_cb;
	discovery_state_changed_callback discovery_state_changed_cb;
	pin_request_callback pin_request_cb;
	ssp_request_callback ssp_request_cb;
	bond_state_changed_callback bond_state_changed_cb;
	acl_state_changed_callback acl_state_changed_cb;
	app_gap_started_callback app_gap_started_cb;
	connection_auth_req_callback connection_auth_req_cb;
	le_rx_test_callback le_rx_test_cb;
	le_tx_test_callback le_tx_test_cb;
	le_test_end_callback le_test_end_cb;
} bluetooth_callback_t;

/**
 * Initialize the "Bluetooth" interface.
 * This function should be called before any other goc_bluetooth_xxx functions.
 *
 * Parameters:
 * cbk	Bluetooth event callbacks. If some bluetooth event occurs, one of its callbacks will be called.
 */
void goc_bluetooth_init(bluetooth_callback_t *cbk);

/**
 * Rlease the sources associated with "Bluetooth" interface.
 * This function should be called at the end.
 */
void goc_bluetooth_done();

/**
 * Pre setting local Bluetooth address , it is valid only before Bluetooth is opened  
 *
 * Return:
 * BT_STATUS_SUCCESS if success. BT_STATUS_FAIL otherwise.
 */

bt_status_t goc_bluetooth_preset_addr(bt_bdaddr_t address);

/**
 * Enable Bluetooth.
 *
 * Return:
 * BT_STATUS_SUCCESS if success. BT_STATUS_FAIL otherwise.
 */
bt_status_t goc_bluetooth_enable();

/**
 * Disable Bluetooth.
 *
 * Return:
 * BT_STATUS_SUCCESS if success. BT_STATUS_FAIL otherwise.
 */
bt_status_t goc_bluetooth_disable();

/**
 * Get the Bluetooth version.
 *
 * Return: version string
 * BT_STATUS_SUCCESS if success. BT_STATUS_FAIL otherwise.
 */
char * goc_bluetooth_get_version();

/**
 * Get current Bluetooth state.
 *
 * Return:
 * BT_STATE_ON if Bluetooth is enabled.
 * BT_STATE_OFF if Bluetooth is disabled.
 */
bt_state_t goc_bluetooth_get_state();

/**
 * Get local device name.
 *
 * Return:
 * the name of local Bluetooth device.
 */
bt_bdname_t *goc_bluetooth_get_name();

/**
 * Get local device address.
 *
 * Return:
 * the address of local Bluetooth device.
 */
bt_bdaddr_t *goc_bluetooth_get_address();

/**
 * Get local scan mode.
 *
 * Return:
 * the current scan mode.
 * BT_SCAN_MODE_NONE, local device is invisble.
 * BT_SCAN_MODE_CONNECTABLE, local device can not be discovered but can be connected.
 * BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE, local device can be discovered and connected.
 */
bt_scan_mode_t goc_bluetooth_get_scan_mode();

/**
 * Get class of local device.
 *
 * Return
 * the Class Of Device. the lower 3 bytes is significant.
 */
int goc_bluetooth_get_class();

/**
 * Get the list of bonded devices.
 *
 * Parameters:
 * devices:			[OUT] bt_remote_device_t pointer to hold the bonded devices. As most of <b>size</b> bonded devices will be saved.<p>
 * 					It can be NULL. If so, the number of bonded devices will be set in the second parameter <b>size</b> and the caller can re-call
 * 					this function with the parameters which's size is determinated.
 * size:			[IN/OUT] As input parameter, It specifys the size of first parameter. As output parameter, the actual number will be saved in it.
 *
 * Return:
 *
 * BT_STATUS_SUCCESS if bonded device is return successfully. BT_STATUS_FAIL otherwise.
 */
bt_status_t goc_bluetooth_get_bonded_devices(bt_remote_device_t *devices, int *size);

/**
 * Set the name of local device.
 *
 * Parameters:
 * name		the name to be set
 *
 * Return:
 * BT_STATUS_SUCCESS if success. BT_STATUS_FAIL otherwise.
 */
bt_status_t goc_bluetooth_set_name(bt_bdname_t name);

/**
 * Set the scan mode of local device.
 *
 * Parameters:
 * mode		the scan mode to be set. Please refer to <b>goc_bluetooth_get_scan_mode</b>
 *
 * Return:
 * BT_STATUS_SUCCESS if success. BT_STATUS_FAIL otherwise.
 */
bt_status_t goc_bluetooth_set_scan_mode(bt_scan_mode_t mode);

/**
 * Set the duration of that the local device can be discovered by nearby Bluetooth devices.
 *
 * Parameters:
 * timeout		the duration.
 *
 * Return:
 * BT_STATUS_SUCCESS if success. BT_STATUS_FAIL otherwise.
 */
bt_status_t goc_bluetooth_set_discoverable_timeout(int timeout);

/**
 * Set the interval of inquiry/discover procedure.
 *
 * Parameters:
 * interval discovery interval.
 *
 * Return:
 * BT_STATUS_SUCCESS if success. BT_STATUS_FAIL otherwise.
 */
bt_status_t goc_bluetooth_set_discovery_internval(int interval);

/**
 * Set the max number of the bonded devices which will saved in local storage.
 *
 * Parameters:
 * num  The max number.
 *
 * Return:
 * BT_STATUS_SUCCESS if success. BT_STATUS_FAIL otherwise.
 */
bt_status_t goc_bluetooth_set_number_of_bonded_devices(int num);

/**
 * Get the max number of the bonded devices which will saved in local storage.
 *
 * Parameters:
 *
 * Return: the max number of bonded devices.
 */
int goc_bluetooth_get_number_of_bonded_devices();

/**
 * Start to discover remote devices.
 * <b>bluetooth_callback_t#device_found_cb</b> will be called if a device is found.
 * <b>bluetooth_callback_t#discovery_state_changed_cb</b> will be called if the discovery is started.
 *
 * Return:
 * BT_STATUS_SUCCESS if success. BT_STATUS_FAIL otherwise.
 */
bt_status_t goc_bluetooth_start_discovery();

/**
 * Stopping the discover remote devices.
 * <b>bluetooth_callback_t#discovery_state_changed_cb will be called if the discovery is stopped. </b>
 *
 * Return:
 * BT_STATUS_SUCCESS if success. BT_STATUS_FAIL otherwise.
 */
bt_status_t goc_bluetooth_stop_discovery();

/**
 * Pair with a specified device.
 * If this procedure succeed, <b>bluetooth_callback_t#pin_request_callback</b> or <b>bluetooth_callback_t#ssp_request_callback</b>
 * will be called. Then user can call <b>goc_bluetooth_pin_reply</b> or <b>goc_bluetooth_ssp_reply</b> to reply with the pincode or passkey.
 *
 * Parameters:
 * address		The address of the specifed device.
 *
 * Return:
 * BT_STATUS_SUCCESS if success. BT_STATUS_FAIL otherwise.
 */
bt_status_t goc_bluetooth_create_bond(bt_bdaddr_t address);

/**
 * Delete the link key associated with the remote device, and immediately terminate connections to that device that require
 * authentication and encryption.
 *
 * Parameters:
 * address		The address of the specifed device.
 *
 * Return:
 * BT_STATUS_SUCCESS if success. BT_STATUS_FAIL otherwise.
 */
bt_status_t goc_bluetooth_remove_bond(bt_bdaddr_t address);

/**
 * Cancel an in-progress pairing request.
 *
 * Parameters:
 * address		The address of the specifed device.
 *
 * Return:
 * BT_STATUS_SUCCESS if success. BT_STATUS_FAIL otherwise.
 */
bt_status_t goc_bluetooth_cancel_bond(bt_bdaddr_t address);

/**
 * Get the connection state of a specified device.
 *
 * Return:
 * BT_ACL_STATE_CONNECTED if there is at least one open connection to this device.
 */
bt_acl_state_t goc_bluetooth_get_connection_state(bt_bdaddr_t address);

/**
 * Reply the pincode to the remote device which request to pair with local deivce or is requested to be paired by local device before.
 *
 * Parameters:
 * address		The address of the specifed device.
 * accept		Whether accept to pair.
 * pin_len		The length of the pincode.
 * pincode		The pincode which is a text string.
 *
 * Return:
 * BT_STATUS_SUCCESS if success. BT_STATUS_FAIL otherwise.
 */
bt_status_t goc_bluetooth_pin_reply(bt_bdaddr_t address, uint8_t accept, uint16_t pin_len, uint8_t * pincode);

/**
 * Reply to the remote device which request to pair with local deivce or is requested to be paired by local device before
 * using Simple Secure pairing mode.
 *
 * Parameters:
 * address		The address of the specifed device.
 * ssp_variant	The SSP pairing variant:
 * 					BT_SSP_VARIANT_PASSKEY_CONFIRMATION,
 * 					BT_SSP_VARIANT_PASSKEY_ENTRY
 * 					BT_SSP_VARIANT_CONSENT,
 * 					BT_SSP_VARIANT_PASSKEY_NOTIFICATION,
 * accept		Whether accept to pair.
 * pincode		The pincode which is a text string.
 *
 * Return:
 * BT_STATUS_SUCCESS if success. BT_STATUS_FAIL otherwise.
 */
bt_status_t goc_bluetooth_ssp_reply(bt_bdaddr_t address, uint8_t ssp_variant, uint8_t accept, int passkey);

/**
 * Get the priority of the remote deivce. The priority is related to the connection time. The more recently connected, the higher priority.
 * If the device never be connected, the priority is 0.
 *
 * Parameters:
 * address	The address of the specified device.
 *
 * Return:
 * the priority of the device.
 */
uint8_t goc_bluetooth_get_device_priority(bt_bdaddr_t address);

/**
 * Get the manufacturer code of the remote deivce.
 * This function is specific to the distinguish whether the remote deivce is an Apple device.
 *
 * Parameters:
 * address	The address of the specified device.
 *
 * Return:
 * the manufacturer code. Please see {@link bt_manufacturer_code_t}.
 */
bt_manufacturer_code_t goc_bluetooth_get_manufacturer_code(bt_bdaddr_t address);
/*
 * Choose to authorize or reject connections
 * Parameters:
 * address  The address of the specified device.
 * profile_id profile id of connection
 * accept authorize or reject 
 *
 * Return:
 * BT_STATUS_SUCCESS if success. BT_STATUS_FAIL otherwise.
 **/
bt_status_t goc_bluetooth_connection_auth(bt_bdaddr_t address, uint8_t profile_id, uint8_t accept);

bt_status_t goc_bluetooth_os_suspend_action();

bt_status_t goc_bluetooth_os_wakeup_action();

bt_status_t goc_bluetooth_le_receiver_test(uint8_t rx_frequency);

bt_status_t goc_bluetooth_le_transmitter_test(uint8_t tx_frequency, uint8_t length_of_test_data, uint8_t packet_payload);

bt_status_t goc_bluetooth_le_test_end();

#ifdef __cplusplus
}
#endif


#endif /*_GOC_BLUETOOTH_H__*/
