
#include "droneID_utils.h"
#include "DSPF_sp_fftSPxSP_cn.h"
#include "burst_process_module.h"
#include "turbo_dec_process.h"
#include "testData/testData_get_process.h"
#include "../alg_init.h"


/* global data declaration */
bool g_initFlag = false;
Cplxf_t g_burst[LENGTH_BURST] = { { 0.0f } };
Cplxf_t g_padBurst[LENGTH_PADDED_BURST] = { { 0.0f } };
Cplxf_t g_padBurst2[LENGTH_PADDED_BURST] = { { 0.0f } };
Cplxf_t g_cpCorrScores[NUM_PADDING_SAMPLE * NUM_SYMBOL_PER_BURST] = { { 0.0f } };
Cplxf_t g_cpCorrScores2[NUM_PADDING_SAMPLE * NUM_SYMBOL_PER_BURST] = { { 0.0f } };
Cplxf_t g_scBuff[LENGTH_SUBCARRIER_BUFF] = { { 0.0f } };
Cplxf_t g_scBuff2[LENGTH_SUBCARRIER_BUFF] = { { 0.0f } };
Cplxf_t g_dataScBuff[LENGTH_DATA_CARRIER_BUFF] = { { 0.0f } };
int8_t g_deMapOut[LENGTH_DEMAP_OUT_BIT] = { 0 };
float g_qpskDeMapLogOut[LENGTH_DEMAP_OUT_BIT] = { 0 };
uint8_t g_decodeOut[LENGTH_DECODE_OUT_BYTE] = { 0 };
uint8_t g_decodeOutBit[LENGTH_DECODE_OUT_BIT] = { 0 };
Cplxf_t g_currTimeData[SIZE_FFT] = { { 0.0f } };
Cplxf_t g_currFreqData[SIZE_FFT] = { { 0.0f } };
Cplxf_t g_chEst[NUM_DATA_CARRIER] = { { 0.0f } };
Cplxf_t g_chEst1[NUM_DATA_CARRIER] = { { 0.0f } };
Cplxf_t g_chEst2[NUM_DATA_CARRIER] = { { 0.0f } };
Cplxf_t g_chEst5[NUM_DATA_CARRIER] = { { 0.0f } };
Cplxf_t g_LS_Est4[NUM_DATA_CARRIER] = { { 0.0f } };
Cplxf_t g_LS_Est6[NUM_DATA_CARRIER] = { { 0.0f } };
Cplxf_t g_LS_DFT_Est4[NUM_DATA_CARRIER] = { { 0.0f } };
Cplxf_t g_LS_DFT_Est5[NUM_DATA_CARRIER] = { { 0.0f } };
Cplxf_t g_LS_DFT_Est6[NUM_DATA_CARRIER] = { { 0.0f } };
Cplxf_t g_rxData[NUM_DATA_CARRIER] = { { 0.0f } };
Cplxf_t g_rxData2[NUM_DATA_CARRIER] = { { 0.0f } };
Cplxf_t g_mimoOutData[NUM_DATA_CARRIER] = { { 0.0f } };
float g_normalizedFactor[NUM_DATA_CARRIER] = { 0.0f };
float g_x_sp[2*SIZE_FFT] = { 0.0f };
float g_y_sp[2*SIZE_FFT] = { 0.0f };
float g_w_sp[2*SIZE_FFT] = { 0.0f };
Cplxf_t g_Ht[SIZE_FFT] = { { 0.0f } };
Cplxf_t g_Ht_in_out[SIZE_FFT] = { { 0.0f } };
Cplxf_t g_Ht_DFT_in_out[SIZE_FFT] = { { 0.0f } };
float g_Ht_in_sp[2*SIZE_FFT] = { 0.0f };
float g_Ht_out_sp[2*SIZE_FFT] = { 0.0f };
float g_Hk_in_sp[2*SIZE_FFT] = { 0.0f };
float g_Hk_out_sp[2*SIZE_FFT] = { 0.0f };
int g_scrSeq[LENGTH_DEMAP_OUT_BIT] = { 0 };
int g_LFSR1[LENGTH_LFSR] = { 0 };
int g_LFSR2[LENGTH_LFSR] = { 0 };
float g_y1r[LENGTH_BURST * 2 + NUM_FILTER_TAP + 1 - 2] = { 0.0f };
float g_y2r[LENGTH_BURST * 2 + NUM_FILTER_TAP + 1 - 2] = { 0.0f };
float g_y1i[LENGTH_BURST * 2 + NUM_FILTER_TAP + 1 - 2] = { 0.0f };
float g_y2i[LENGTH_BURST * 2 + NUM_FILTER_TAP + 1 - 2] = { 0.0f };
float g_zcSnr[2] = { 0.0f };
float g_evm = 0.0f;

Cplxf_t g_zcData[2][NUM_DATA_CARRIER] = {
	{ {1.0,0.0}, {0.99995,0.010454}, {0.99951,0.031359}, {0.99803,0.062686}, {0.99454,0.10436}, {0.98773,0.15618}, {0.976,0.21779},
	{0.95746,0.28856}, {0.93001,0.36754}, {0.89136,0.45329}, {0.83919,0.54384}, {0.77125,0.63654}, {0.68554,0.72804},
	{0.58057,0.81421}, {0.45562,0.89017}, {0.311,0.95041}, {0.14843,0.98892}, {-0.028746,0.99959}, {-0.21523,0.97656},
	{-0.40371,0.91489}, {-0.58482,0.81116}, {-0.74744,0.66433}, {-0.87921,0.47643}, {-0.96738,0.25335}, {-0.99999,0.0052273},
	{-0.96738,-0.25335}, {-0.86384,-0.50377}, {-0.68933,-0.72444}, {-0.45096,-0.89254}, {-0.16392,-0.98647}, {0.14843,-0.98892},
	{0.45562,-0.89017}, {0.72264,-0.69122}, {0.91383,-0.4061}, {0.99803,-0.062686}, {0.95439,0.29856}, {0.77786,0.62844},
	{0.48331,0.87545}, {0.10695,0.99426}, {-0.29606,0.95517}, {-0.65844,0.75263}, {-0.91169,0.41087}, {-0.99988,-0.015681},
	{-0.89372,-0.44863}, {-0.60165,-0.79876}, {-0.17422,-0.98471}, {0.30105,-0.95361}, {0.71537,-0.69874}, {0.96328,-0.26848},
	{0.97123,0.23814}, {0.72264,0.69122}, {0.271,0.96258}, {-0.26596,0.96398}, {-0.73339,0.67981}, {-0.98331,0.18194},
	{-0.92413,-0.38208}, {-0.5591,-0.8291}, {0.0026136,-1}, {0.57203,-0.82023}, {0.94108,-0.3382}, {0.96042,0.27854},
	{0.60582,0.7956}, {0.0026136,1}, {-0.60997,0.79242}, {-0.96997,0.24322}, {-0.90735,-0.42038}, {-0.4322,-0.90178},
	{0.25082,-0.96803}, {0.82173,-0.56988}, {0.99339,0.11475}, {0.66237,0.74918}, {-0.018294,0.99983}, {-0.69687,0.7172},
	{-0.99933,0.036583}, {-0.74046,-0.6721}, {-0.049639,-0.99877}, {0.67789,-0.73516}, {0.99978,-0.020908}, {0.70061,0.71355},
	{-0.049639,0.99877}, {-0.77456,0.6325}, {-0.9869,-0.16134}, {-0.52395,-0.85175}, {0.311,-0.95041}, {0.93001,-0.36754},
	{0.87163,0.49016}, {0.15876,0.98732}, {-0.68172,0.73161}, {-0.99507,-0.099155}, {-0.51501,-0.85718}, {0.38931,-0.92111},
	{0.976,-0.21779}, {0.73693,0.67596}, {-0.14326,0.98969}, {-0.9029,0.42984}, {-0.85312,-0.52172}, {-0.018294,-0.99983},
	{0.83919,-0.54384}, {0.90064,0.43456}, {0.086143,0.99628}, {-0.81874,0.57417}, {-0.9029,-0.42984}, {-0.060077,-0.99819},
	{0.85038,-0.52617}, {0.86119,0.50828}, {-0.060077,0.99819}, {-0.92008,0.39172}, {-0.75435,-0.65648}, {0.271,-0.96258},
	{0.98773,-0.15618}, {0.54603,0.83777}, {-0.5504,0.8349}, {-0.98331,-0.18194}, {-0.20501,-0.97876}, {0.83346,-0.55258},
	{0.81572,0.57844}, {-0.25587,0.96671}, {-0.99605,0.088747}, {-0.41325,-0.91062}, {0.72983,-0.68363}, {0.87671,0.48102},
	{-0.19477,0.98085}, {-0.99507,0.099155}, {-0.37482,-0.9271}, {0.79083,-0.61204}, {0.79718,0.60374}, {-0.38449,0.92313},
	{-0.98853,-0.15101}, {-0.080934,-0.99672}, {0.95439,-0.29856}, {0.49244,0.87035}, {-0.75435,0.65648}, {-0.78762,-0.61616},
	{0.4649,-0.88536}, {0.95122,0.30852}, {-0.15359,0.98813}, {-0.99999,-0.0052273}, {-0.1329,-0.99113}, {0.96604,-0.2584},
	{0.36997,0.92904}, {-0.88414,0.46721}, {-0.5504,-0.8349}, {0.78439,-0.62027}, {0.67789,0.73516}, {-0.68933,0.72444},
	{-0.76117,-0.64855}, {0.6141,-0.78922}, {0.80963,0.58694}, {-0.56773,0.82321}, {-0.83056,-0.55693}, {0.55476,-0.83201},
	{0.82764,0.56126}, {-0.57631,0.81723}, {-0.80033,-0.59956}, {0.63047,-0.77621}, {0.74396,0.66822}, {-0.71171,0.70247},
	{-0.65054,-0.75947}, {0.80963,-0.58694}, {0.51053,0.85986}, {-0.90735,0.42038}, {-0.31597,-0.94877}, {0.98034,-0.19733},
	{0.065294,0.99787}, {-0.99693,-0.078329}, {0.23052,-0.97307}, {0.92212,0.38691}, {-0.54164,0.84061}, {-0.72624,-0.68744},
	{0.81572,-0.57844}, {0.39892,0.91698}, {-0.98135,0.19221}, {0.033971,-0.99942}, {0.96328,0.26848}, {-0.49698,0.86776},
	{-0.71171,-0.70247}, {0.86646,-0.49925}, {0.24068,0.9706}, {-0.99889,-0.047028}, {0.34066,-0.94019}, {0.79083,0.61204},
	{-0.83056,0.55693}, {-0.25587,-0.96671}, {0.9965,0.083539}, {-0.42275,0.90625}, {-0.69687,-0.7172}, {0.92212,-0.38691},
	{0.013068,0.99991}, {-0.92807,-0.3724}, {0.70803,-0.70618}, {0.36024,0.93286}, {-0.99835,-0.057468}, {0.47413,-0.88045},
	{0.58905,0.80809}, {-0.98516,0.17165}, {0.29107,-0.9567}, {0.71537,0.69874}, {-0.95282,0.30354}, {0.18964,-0.98185},
	{0.76455,0.64457}, {-0.93929,0.34311}, {0.17937,-0.98378}, {0.75091,0.66041}, {-0.95594,0.29357}, {0.26092,-0.96536},
	{0.67017,0.74221}, {-0.98853,0.15101}, {0.42748,-0.90402}, {0.50151,0.86515}, {-0.99605,-0.088747}, {0.6545,-0.75606},
	{0.22034,0.97542}, {-0.91169,-0.41087}, {0.88169,-0.47183}, {-0.17422,0.98471}, {-0.65844,-0.75263}, {0.99951,-0.031359},
	{-0.61822,0.786}, {-0.19477,-0.98085}, {0.86646,0.49925}, {-0.94959,0.31349}, {0.40849,-0.91276}, {0.38931,0.92111},
	{-0.93566,-0.35291}, {0.90514,-0.42512}, {-0.33574,0.94196}, {-0.42275,-0.90625}, {0.9338,0.3578}, {-0.92413,0.38208},
	{0.41801,-0.90844}, {0.30105,0.95361}, {-0.85853,-0.51277}, {0.98425,-0.17679}, {-0.63452,0.77291}, {-0.0078408,-0.99997},
	{0.63855,0.76958}, {-0.97929,-0.20245}, {0.89605,-0.44395}, {-0.4416,0.89721}, {-0.18451,-0.98283}, {0.72983,0.68363},
	{-0.99147,-0.13031}, {0.88657,-0.46259}, {-0.46952,0.88292}, {-0.10176,-0.99481}, {0.63047,0.77621}, {-0.94959,-0.31349},
	{0.97123,-0.23814}, {-0.70433,0.70987}, {0.24068,-0.9706}, {0.28105,0.95969}, {-0.71902,-0.69499}, {0.96604,0.2584},
	{-0.97246,0.23306}, {0.75091,-0.66041}, {-0.36511,0.93096}, {-0.09135,-0.99582}, {0.51949,0.85448}, {-0.83634,-0.54821},
	{0.98931,0.14584}, {-0.96187,0.27352}, {0.77125,-0.63654}, {-0.46027,0.88778}, {0.086143,-0.99628}, {0.29107,0.9567},
	{-0.61822,-0.786}, {0.85583,0.51725}, {-0.98135,-0.19221}, {0.98931,-0.14584}, {-0.88898,0.45794}, {0.70061,-0.71355},
	{-0.45096,0.89254}, {0.16907,-0.9856}, {0.11734,0.99309}, {-0.38449,-0.92313}, {0.6141,0.78922}, {-0.79402,-0.6079},
	{0.91802,0.39652}, {-0.98516,-0.17165}, {0.99863,-0.052249}, {-0.96467,0.26344}, {0.89136,-0.45329}, {-0.78762,0.61616},
	{0.66237,-0.74918}, {-0.52395,0.85175}, {0.37966,-0.92512}, {-0.23561,0.97185}, {0.096554,-0.99533}, {0.033971,0.99942},
	{-0.15359,-0.98813}, {0.26092,0.96536}, {-0.35536,-0.93473}, {0.43691,0.89951}, {-0.50602,-0.86252}, {0.56342,0.82617},
	{-0.60997,-0.79242}, {0.64656,0.76286}, {-0.67404,-0.7387}, {0.69311,0.72083}, {-0.70433,-0.70987}, {-0.70433,-0.70987},
	{0.69311,0.72083}, {-0.67404,-0.7387}, {0.64656,0.76286}, {-0.60997,-0.79242}, {0.56342,0.82617}, {-0.50602,-0.86252},
	{0.43691,0.89951}, {-0.35536,-0.93473}, {0.26092,0.96536}, {-0.15359,-0.98813}, {0.033971,0.99942}, {0.096554,-0.99533},
	{-0.23561,0.97185}, {0.37966,-0.92512}, {-0.52395,0.85175}, {0.66237,-0.74918}, {-0.78762,0.61616}, {0.89136,-0.45329},
	{-0.96467,0.26344}, {0.99863,-0.052249}, {-0.98516,-0.17165}, {0.91802,0.39652}, {-0.79402,-0.6079}, {0.6141,0.78922},
	{-0.38449,-0.92313}, {0.11734,0.99309}, {0.16907,-0.9856}, {-0.45096,0.89254}, {0.70061,-0.71355}, {-0.88898,0.45794},
	{0.98931,-0.14584}, {-0.98135,-0.19221}, {0.85583,0.51725}, {-0.61822,-0.786}, {0.29107,0.9567}, {0.086143,-0.99628},
	{-0.46027,0.88778}, {0.77125,-0.63654}, {-0.96187,0.27352}, {0.98931,0.14584}, {-0.83634,-0.54821}, {0.51949,0.85448},
	{-0.09135,-0.99582}, {-0.36511,0.93096}, {0.75091,-0.66041}, {-0.97246,0.23306}, {0.96604,0.2584}, {-0.71902,-0.69499},
	{0.28105,0.95969}, {0.24068,-0.9706}, {-0.70433,0.70987}, {0.97123,-0.23814}, {-0.94959,-0.31349}, {0.63047,0.77621},
	{-0.10176,-0.99481}, {-0.46952,0.88292}, {0.88657,-0.46259}, {-0.99147,-0.13031}, {0.72983,0.68363}, {-0.18451,-0.98283},
	{-0.4416,0.89721}, {0.89605,-0.44395}, {-0.97929,-0.20245}, {0.63855,0.76958}, {-0.0078408,-0.99997}, {-0.63452,0.77291},
	{0.98425,-0.17679}, {-0.85853,-0.51277}, {0.30105,0.95361}, {0.41801,-0.90844}, {-0.92413,0.38208}, {0.9338,0.3578},
	{-0.42275,-0.90625}, {-0.33574,0.94196}, {0.90514,-0.42512}, {-0.93566,-0.35291}, {0.38931,0.92111}, {0.40849,-0.91276},
	{-0.94959,0.31349}, {0.86646,0.49925}, {-0.19477,-0.98085}, {-0.61822,0.786}, {0.99951,-0.031359}, {-0.65844,-0.75263},
	{-0.17422,0.98471}, {0.88169,-0.47183}, {-0.91169,-0.41087}, {0.22034,0.97542}, {0.6545,-0.75606}, {-0.99605,-0.088747},
	{0.50151,0.86515}, {0.42748,-0.90402}, {-0.98853,0.15101}, {0.67017,0.74221}, {0.26092,-0.96536}, {-0.95594,0.29357},
	{0.75091,0.66041}, {0.17937,-0.98378}, {-0.93929,0.34311}, {0.76455,0.64457}, {0.18964,-0.98185}, {-0.95282,0.30354},
	{0.71537,0.69874}, {0.29107,-0.9567}, {-0.98516,0.17165}, {0.58905,0.80809}, {0.47413,-0.88045}, {-0.99835,-0.057468},
	{0.36024,0.93286}, {0.70803,-0.70618}, {-0.92807,-0.3724}, {0.013068,0.99991}, {0.92212,-0.38691}, {-0.69687,-0.7172},
	{-0.42275,0.90625}, {0.9965,0.083539}, {-0.25587,-0.96671}, {-0.83056,0.55693}, {0.79083,0.61204}, {0.34066,-0.94019},
	{-0.99889,-0.047028}, {0.24068,0.9706}, {0.86646,-0.49925}, {-0.71171,-0.70247}, {-0.49698,0.86776}, {0.96328,0.26848},
	{0.033971,-0.99942}, {-0.98135,0.19221}, {0.39892,0.91698}, {0.81572,-0.57844}, {-0.72624,-0.68744}, {-0.54164,0.84061},
	{0.92212,0.38691}, {0.23052,-0.97307}, {-0.99693,-0.078329}, {0.065294,0.99787}, {0.98034,-0.19733}, {-0.31597,-0.94877},
	{-0.90735,0.42038}, {0.51053,0.85986}, {0.80963,-0.58694}, {-0.65054,-0.75947}, {-0.71171,0.70247}, {0.74396,0.66822},
	{0.63047,-0.77621}, {-0.80033,-0.59956}, {-0.57631,0.81723}, {0.82764,0.56126}, {0.55476,-0.83201}, {-0.83056,-0.55693},
	{-0.56773,0.82321}, {0.80963,0.58694}, {0.6141,-0.78922}, {-0.76117,-0.64855}, {-0.68933,0.72444}, {0.67789,0.73516},
	{0.78439,-0.62027}, {-0.5504,-0.8349}, {-0.88414,0.46721}, {0.36997,0.92904}, {0.96604,-0.2584}, {-0.1329,-0.99113},
	{-0.99999,-0.0052273}, {-0.15359,0.98813}, {0.95122,0.30852}, {0.4649,-0.88536}, {-0.78762,-0.61616}, {-0.75435,0.65648},
	{0.49244,0.87035}, {0.95439,-0.29856}, {-0.080934,-0.99672}, {-0.98853,-0.15101}, {-0.38449,0.92313}, {0.79718,0.60374},
	{0.79083,-0.61204}, {-0.37482,-0.9271}, {-0.99507,0.099155}, {-0.19477,0.98085}, {0.87671,0.48102}, {0.72983,-0.68363},
	{-0.41325,-0.91062}, {-0.99605,0.088747}, {-0.25587,0.96671}, {0.81572,0.57844}, {0.83346,-0.55258}, {-0.20501,-0.97876},
	{-0.98331,-0.18194}, {-0.5504,0.8349}, {0.54603,0.83777}, {0.98773,-0.15618}, {0.271,-0.96258}, {-0.75435,-0.65648},
	{-0.92008,0.39172}, {-0.060077,0.99819}, {0.86119,0.50828}, {0.85038,-0.52617}, {-0.060077,-0.99819}, {-0.9029,-0.42984},
	{-0.81874,0.57417}, {0.086143,0.99628}, {0.90064,0.43456}, {0.83919,-0.54384}, {-0.018294,-0.99983}, {-0.85312,-0.52172},
	{-0.9029,0.42984}, {-0.14326,0.98969}, {0.73693,0.67596}, {0.976,-0.21779}, {0.38931,-0.92111}, {-0.51501,-0.85718},
	{-0.99507,-0.099155}, {-0.68172,0.73161}, {0.15876,0.98732}, {0.87163,0.49016}, {0.93001,-0.36754}, {0.311,-0.95041},
	{-0.52395,-0.85175}, {-0.9869,-0.16134}, {-0.77456,0.6325}, {-0.049639,0.99877}, {0.70061,0.71355}, {0.99978,-0.020908},
	{0.67789,-0.73516}, {-0.049639,-0.99877}, {-0.74046,-0.6721}, {-0.99933,0.036583}, {-0.69687,0.7172}, {-0.018294,0.99983},
	{0.66237,0.74918}, {0.99339,0.11475}, {0.82173,-0.56988}, {0.25082,-0.96803}, {-0.4322,-0.90178}, {-0.90735,-0.42038},
	{-0.96997,0.24322}, {-0.60997,0.79242}, {0.0026136,1}, {0.60582,0.7956}, {0.96042,0.27854}, {0.94108,-0.3382},
	{0.57203,-0.82023}, {0.0026136,-1}, {-0.5591,-0.8291}, {-0.92413,-0.38208}, {-0.98331,0.18194}, {-0.73339,0.67981},
	{-0.26596,0.96398}, {0.271,0.96258}, {0.72264,0.69122}, {0.97123,0.23814}, {0.96328,-0.26848}, {0.71537,-0.69874},
	{0.30105,-0.95361}, {-0.17422,-0.98471}, {-0.60165,-0.79876}, {-0.89372,-0.44863}, {-0.99988,-0.015681}, {-0.91169,0.41087},
	{-0.65844,0.75263}, {-0.29606,0.95517}, {0.10695,0.99426}, {0.48331,0.87545}, {0.77786,0.62844}, {0.95439,0.29856},
	{0.99803,-0.062686}, {0.91383,-0.4061}, {0.72264,-0.69122}, {0.45562,-0.89017}, {0.14843,-0.98892}, {-0.16392,-0.98647},
	{-0.45096,-0.89254}, {-0.68933,-0.72444}, {-0.86384,-0.50377}, {-0.96738,-0.25335}, {-0.99999,0.0052273}, {-0.96738,0.25335},
	{-0.87921,0.47643}, {-0.74744,0.66433}, {-0.58482,0.81116}, {-0.40371,0.91489}, {-0.21523,0.97656}, {-0.028746,0.99959},
	{0.14843,0.98892}, {0.311,0.95041}, {0.45562,0.89017}, {0.58057,0.81421}, {0.68554,0.72804}, {0.77125,0.63654},
	{0.83919,0.54384}, {0.89136,0.45329}, {0.93001,0.36754}, {0.95746,0.28856}, {0.976,0.21779}, {0.98773,0.15618},
	{0.99454,0.10436}, {0.99803,0.062686}, {0.99951,0.031359}, {0.99995,0.010454}, {1.0,0.0} },

	{ {1.00000,0.00000}, {0.03397,-0.99942}, {-0.10176,0.99481}, {-0.97929,-0.20245}, {-0.94283,-0.33327}, {-0.48788,0.87291},
	{0.65450,-0.75606}, {0.58057,0.81421}, {0.34066,0.94019}, {0.99913,-0.04181}, {-0.95594,-0.29357}, {0.62232,-0.78276},
	{0.88169,-0.47183}, {-0.04964,-0.99877}, {-0.41325,0.91062}, {-0.59327,-0.80500}, {-0.09135,-0.99582}, {-0.88414,-0.46721},
	{0.45562,0.89017}, {-0.98516,-0.17165}, {-0.65844,-0.75263}, {-0.99999,0.00523}, {0.73693,0.67596}, {-0.99889,0.04703},
	{-0.71902,-0.69499}, {-0.99889,-0.04703}, {0.59747,0.80189}, {-0.96187,-0.27352}, {-0.33574,-0.94196}, {-0.80033,-0.59956},
	{-0.09135,0.99582}, {-0.41325,-0.91062}, {0.61410,-0.78922}, {0.21013,-0.97767}, {-0.97929,0.20245}, {0.83346,-0.55258},
	{0.80345,0.59537}, {0.94794,0.31845}, {0.04442,-0.99901}, {0.19989,0.97982}, {-0.91594,0.40132}, {-0.83056,0.55693},
	{0.67017,0.74221}, {-0.74744,-0.66433}, {0.60582,-0.79560}, {0.57203,-0.82023}, {-0.82469,-0.56558}, {0.80963,0.58694},
	{-0.63452,0.77291}, {-0.70433,0.70987}, {0.61410,0.78922}, {-0.47873,-0.87796}, {0.95439,-0.29856}, {0.99732,-0.07312},
	{0.18964,-0.98185}, {-0.46952,0.88292}, {-0.68172,-0.73161}, {-0.37482,-0.92710}, {-0.99988,-0.01568}, {0.90064,0.43456},
	{-0.79402,0.60790}, {-0.98853,0.15101}, {-0.37482,0.92710}, {0.81572,-0.57844}, {0.01307,0.99991}, {-0.58482,0.81116},
	{0.27100,0.96258}, {0.41801,-0.90844}, {0.38931,0.92111}, {-0.36511,0.93096}, {0.37966,0.92512}, {0.43691,-0.89951},
	{0.24068,0.97060}, {-0.61822,0.78600}, {-0.03919,0.99923}, {0.85038,-0.52617}, {-0.44160,0.89721}, {-0.99769,0.06790},
	{-0.84762,0.53061}, {0.85038,0.52617}, {-0.99147,-0.13031}, {-0.25587,-0.96671}, {-0.57631,-0.81723}, {-0.59327,0.80500},
	{0.34066,-0.94019}, {0.99558,0.09395}, {0.99214,-0.12513}, {-0.30603,-0.95202}, {0.44629,0.89489}, {-0.83634,0.54821},
	{-0.78762,0.61616}, {0.65450,0.75606}, {-0.66628,-0.74570}, {0.75777,-0.65252}, {0.79083,-0.61204}, {-0.54164,-0.84061},
	{0.43691,0.89951}, {-0.95594,0.29357}, {-0.99398,0.10955}, {-0.11215,0.99369}, {0.36024,-0.93286}, {0.79083,0.61204},
	{0.55476,0.83201}, {0.97367,-0.22798}, {-0.98690,-0.16134}, {0.55476,-0.83201}, {0.86646,-0.49925}, {-0.02875,-0.99959},
	{-0.47873,0.87796}, {-0.48788,-0.87291}, {0.08614,-0.99628}, {-0.75435,-0.65648}, {0.18964,0.98185}, {-0.87418,-0.48560},
	{-0.32587,-0.94541}, {-0.90735,-0.42038}, {0.33081,0.94370}, {-0.87921,-0.47643}, {-0.20501,-0.97876}, {-0.76791,-0.64056},
	{-0.06008,0.99819}, {-0.51501,-0.85718}, {0.44629,-0.89489}, {-0.07051,-0.99751}, {-0.84202,0.53944}, {0.51053,-0.85986},
	{0.99454,0.10436}, {0.95746,-0.28856}, {-0.60997,-0.79242}, {0.83346,0.55258}, {-0.28606,0.95821}, {-0.02875,0.99959},
	{0.98034,-0.19733}, {-0.92413,0.38208}, {-0.52395,-0.85175}, {-0.62640,-0.77950}, {-0.71902,0.69499}, {0.67789,-0.73516},
	{0.75091,0.66041}, {0.74396,0.66822}, {0.70061,-0.71355}, {-0.75435,0.65648}, {-0.56773,-0.82321}, {-0.44160,-0.89721},
	{-0.96187,0.27352}, {0.99803,-0.06269}, {-0.18451,0.98283}, {-0.45096,0.89254}, {0.70803,0.70618}, {-0.42275,-0.90625},
	{0.99863,-0.05225}, {0.93380,0.35780}, {0.72983,-0.68363}, {-0.96467,0.26344}, {0.25082,-0.96803}, {0.72264,-0.69122},
	{-0.17422,-0.98471}, {-0.43220,0.90178}, {-0.45096,-0.89254}, {0.22034,-0.97542}, {-0.58482,-0.81116}, {-0.13290,0.99113},
	{-0.60165,-0.79876}, {0.17937,-0.98378}, {-0.50602,-0.86252}, {-0.35536,0.93473}, {-0.27603,-0.96115}, {0.63047,-0.77621},
	{0.10695,-0.99426}, {-0.90735,0.42038}, {0.58905,-0.80809}, {0.98773,0.15618}, {0.96042,-0.27854}, {-0.63452,-0.77291},
	{0.87163,0.49016}, {-0.17422,0.98471}, {0.12772,0.99181}, {0.92212,-0.38691}, {-0.80655,0.59116}, {-0.74046,-0.67210},
	{-0.84202,-0.53944}, {-0.42275,0.90625}, {0.33081,-0.94370}, {0.96328,0.26848}, {0.97123,0.23814}, {0.24068,-0.97060},
	{-0.27603,0.96115}, {-0.93929,-0.34311}, {-0.89836,-0.43926}, {-0.55910,0.82910}, {0.69311,-0.72083}, {0.56342,0.82617},
	{0.35047,0.93658}, {0.99650,-0.08354}, {-0.97484,-0.22288}, {0.53724,-0.84343}, {0.80963,-0.58694}, {-0.21523,-0.97656},
	{-0.22543,0.97426}, {-0.76117,-0.64855}, {-0.34557,-0.93839}, {-0.98135,-0.19221}, {0.71537,0.69874}, {-0.98331,0.18194},
	{-0.89372,-0.44863}, {-0.91169,0.41087}, {0.95746,0.28856}, {-0.86384,0.50377}, {-0.96738,-0.25335}, {-0.87921,0.47643},
	{0.93749,0.34802}, {-0.94626,0.32340}, {-0.83056,-0.55693}, {-0.99966,0.02613}, {0.57203,0.82023}, {-0.91594,-0.40132},
	{-0.10176,-0.99481}, {-0.55040,-0.83490}, {-0.51501,0.85718}, {0.12772,-0.99181}, {0.96869,-0.24828}, {0.82764,-0.56126},
	{-0.78762,-0.61616}, {0.92611,0.37724}, {-0.14326,0.98969}, {0.06529,0.99787}, {0.97123,-0.23814}, {-0.92807,0.37240},
	{-0.46952,-0.88292}, {-0.53282,-0.84623}, {-0.82469,0.56558}, {0.82173,-0.56988}, {0.54603,0.83777}, {0.49244,0.87035},
	{0.91383,-0.40610}, {-0.95896,0.28356}, {-0.12253,-0.99246}, {0.07572,-0.99713}, {-0.95282,-0.30354}, {0.83919,0.54384},
	{-0.76791,0.64056}, {-0.93566,0.35291}, {-0.00784,0.99997}, {0.39892,-0.91698}, {0.66237,0.74918}, {0.25082,0.96803},
	{0.96869,0.24828}, {-0.70433,-0.70987}, {0.97822,-0.20757}, {0.92212,0.38691}, {0.86119,-0.50828}, {-0.99006,-0.14067},
	{0.75091,-0.66041}, {0.99978,0.02091}, {0.71537,-0.69874}, {-0.99933,-0.03658}, {0.77125,-0.63654}, {0.98235,0.18707},
	{0.89136,-0.45329}, {-0.88898,-0.45794}, {0.99339,-0.11475}, {0.62232,0.78276}, {0.93001,0.36754}, {-0.11215,-0.99369},
	{0.53724,0.84343}, {-0.55040,0.83490}, {-0.19477,0.98085}, {0.98773,-0.15618}, {-0.88898,0.45794}, {-0.68933,-0.72444},
	{-0.84762,-0.53061}, {-0.33574,0.94196}, {0.15876,-0.98732}, {0.99995,0.01045}, {0.99454,-0.10436}, {-0.18451,-0.98283},
	{0.23052,0.97307}, {-0.96997,0.24322}, {-0.97484,0.22288}, {0.16907,0.98560}, {-0.08093,-0.99672}, {0.99913,0.04181},
	{0.98034,0.19733}, {0.37966,-0.92512}, {-0.57631,0.81723}, {-0.64257,-0.76623}, {-0.39412,-0.91906}, {-0.99693,0.07833},
	{0.96042,0.27854}, {-0.62640,0.77950}, {-0.89372,0.44863}, {0.00261,1.00000}, {0.47413,-0.88045}, {0.51949,0.85448},
	{-0.01829,0.99983}, {0.81572,0.57844}, {-0.31597,-0.94877}, {0.94108,0.33820}, {0.50151,0.86515}, {0.97822,0.20757},
	{0.97822,0.20757}, {0.50151,0.86515}, {0.94108,0.33820}, {-0.31597,-0.94877}, {0.81572,0.57844}, {-0.01829,0.99983},
	{0.51949,0.85448}, {0.47413,-0.88045}, {0.00261,1.00000}, {-0.89372,0.44863}, {-0.62640,0.77950}, {0.96042,0.27854},
	{-0.99693,0.07833}, {-0.39412,-0.91906}, {-0.64257,-0.76623}, {-0.57631,0.81723}, {0.37966,-0.92512}, {0.98034,0.19733},
	{0.99913,0.04181}, {-0.08093,-0.99672}, {0.16907,0.98560}, {-0.97484,0.22288}, {-0.96997,0.24322}, {0.23052,0.97307},
	{-0.18451,-0.98283}, {0.99454,-0.10436}, {0.99995,0.01045}, {0.15876,-0.98732}, {-0.33574,0.94196}, {-0.84762,-0.53061},
	{-0.68933,-0.72444}, {-0.88898,0.45794}, {0.98773,-0.15618}, {-0.19477,0.98085}, {-0.55040,0.83490}, {0.53724,0.84343},
	{-0.11215,-0.99369}, {0.93001,0.36754}, {0.62232,0.78276}, {0.99339,-0.11475}, {-0.88898,-0.45794}, {0.89136,-0.45329},
	{0.98235,0.18707}, {0.77125,-0.63654}, {-0.99933,-0.03658}, {0.71537,-0.69874}, {0.99978,0.02091}, {0.75091,-0.66041},
	{-0.99006,-0.14067}, {0.86119,-0.50828}, {0.92212,0.38691}, {0.97822,-0.20757}, {-0.70433,-0.70987}, {0.96869,0.24828},
	{0.25082,0.96803}, {0.66237,0.74918}, {0.39892,-0.91698}, {-0.00784,0.99997}, {-0.93566,0.35291}, {-0.76791,0.64056},
	{0.83919,0.54384}, {-0.95282,-0.30354}, {0.07572,-0.99713}, {-0.12253,-0.99246}, {-0.95896,0.28356}, {0.91383,-0.40610},
	{0.49244,0.87035}, {0.54603,0.83777}, {0.82173,-0.56988}, {-0.82469,0.56558}, {-0.53282,-0.84623}, {-0.46952,-0.88292},
	{-0.92807,0.37240}, {0.97123,-0.23814}, {0.06529,0.99787}, {-0.14326,0.98969}, {0.92611,0.37724}, {-0.78762,-0.61616},
	{0.82764,-0.56126}, {0.96869,-0.24828}, {0.12772,-0.99181}, {-0.51501,0.85718}, {-0.55040,-0.83490}, {-0.10176,-0.99481},
	{-0.91594,-0.40132}, {0.57203,0.82023}, {-0.99966,0.02613}, {-0.83056,-0.55693}, {-0.94626,0.32340}, {0.93749,0.34802},
	{-0.87921,0.47643}, {-0.96738,-0.25335}, {-0.86384,0.50377}, {0.95746,0.28856}, {-0.91169,0.41087}, {-0.89372,-0.44863},
	{-0.98331,0.18194}, {0.71537,0.69874}, {-0.98135,-0.19221}, {-0.34557,-0.93839}, {-0.76117,-0.64855}, {-0.22543,0.97426},
	{-0.21523,-0.97656}, {0.80963,-0.58694}, {0.53724,-0.84343}, {-0.97484,-0.22288}, {0.99650,-0.08354}, {0.35047,0.93658},
	{0.56342,0.82617}, {0.69311,-0.72083}, {-0.55910,0.82910}, {-0.89836,-0.43926}, {-0.93929,-0.34311}, {-0.27603,0.96115},
	{0.24068,-0.97060}, {0.97123,0.23814}, {0.96328,0.26848}, {0.33081,-0.94370}, {-0.42275,0.90625}, {-0.84202,-0.53944},
	{-0.74046,-0.67210}, {-0.80655,0.59116}, {0.92212,-0.38691}, {0.12772,0.99181}, {-0.17422,0.98471}, {0.87163,0.49016},
	{-0.63452,-0.77291}, {0.96042,-0.27854}, {0.98773,0.15618}, {0.58905,-0.80809}, {-0.90735,0.42038}, {0.10695,-0.99426},
	{0.63047,-0.77621}, {-0.27603,-0.96115}, {-0.35536,0.93473}, {-0.50602,-0.86252}, {0.17937,-0.98378}, {-0.60165,-0.79876},
	{-0.13290,0.99113}, {-0.58482,-0.81116}, {0.22034,-0.97542}, {-0.45096,-0.89254}, {-0.43220,0.90178}, {-0.17422,-0.98471},
	{0.72264,-0.69122}, {0.25082,-0.96803}, {-0.96467,0.26344}, {0.72983,-0.68363}, {0.93380,0.35780}, {0.99863,-0.05225},
	{-0.42275,-0.90625}, {0.70803,0.70618}, {-0.45096,0.89254}, {-0.18451,0.98283}, {0.99803,-0.06269}, {-0.96187,0.27352},
	{-0.44160,-0.89721}, {-0.56773,-0.82321}, {-0.75435,0.65648}, {0.70061,-0.71355}, {0.74396,0.66822}, {0.75091,0.66041},
	{0.67789,-0.73516}, {-0.71902,0.69499}, {-0.62640,-0.77950}, {-0.52395,-0.85175}, {-0.92413,0.38208}, {0.98034,-0.19733},
	{-0.02875,0.99959}, {-0.28606,0.95821}, {0.83346,0.55258}, {-0.60997,-0.79242}, {0.95746,-0.28856}, {0.99454,0.10436},
	{0.51053,-0.85986}, {-0.84202,0.53944}, {-0.07051,-0.99751}, {0.44629,-0.89489}, {-0.51501,-0.85718}, {-0.06008,0.99819},
	{-0.76791,-0.64056}, {-0.20501,-0.97876}, {-0.87921,-0.47643}, {0.33081,0.94370}, {-0.90735,-0.42038}, {-0.32587,-0.94541},
	{-0.87418,-0.48560}, {0.18964,0.98185}, {-0.75435,-0.65648}, {0.08614,-0.99628}, {-0.48788,-0.87291}, {-0.47873,0.87796},
	{-0.02875,-0.99959}, {0.86646,-0.49925}, {0.55476,-0.83201}, {-0.98690,-0.16134}, {0.97367,-0.22798}, {0.55476,0.83201},
	{0.79083,0.61204}, {0.36024,-0.93286}, {-0.11215,0.99369}, {-0.99398,0.10955}, {-0.95594,0.29357}, {0.43691,0.89951},
	{-0.54164,-0.84061}, {0.79083,-0.61204}, {0.75777,-0.65252}, {-0.66628,-0.74570}, {0.65450,0.75606}, {-0.78762,0.61616},
	{-0.83634,0.54821}, {0.44629,0.89489}, {-0.30603,-0.95202}, {0.99214,-0.12513}, {0.99558,0.09395}, {0.34066,-0.94019},
	{-0.59327,0.80500}, {-0.57631,-0.81723}, {-0.25587,-0.96671}, {-0.99147,-0.13031}, {0.85038,0.52617}, {-0.84762,0.53061},
	{-0.99769,0.06790}, {-0.44160,0.89721}, {0.85038,-0.52617}, {-0.03919,0.99923}, {-0.61822,0.78600}, {0.24068,0.97060},
	{0.43691,-0.89951}, {0.37966,0.92512}, {-0.36511,0.93096}, {0.38931,0.92111}, {0.41801,-0.90844}, {0.27100,0.96258},
	{-0.58482,0.81116}, {0.01307,0.99991}, {0.81572,-0.57844}, {-0.37482,0.92710}, {-0.98853,0.15101}, {-0.79402,0.60790},
	{0.90064,0.43456}, {-0.99988,-0.01568}, {-0.37482,-0.92710}, {-0.68172,-0.73161}, {-0.46952,0.88292}, {0.18964,-0.98185},
	{0.99732,-0.07312}, {0.95439,-0.29856}, {-0.47873,-0.87796}, {0.61410,0.78922}, {-0.70433,0.70987}, {-0.63452,0.77291},
	{0.80963,0.58694}, {-0.82469,-0.56558}, {0.57203,-0.82023}, {0.60582,-0.79560}, {-0.74744,-0.66433}, {0.67017,0.74221},
	{-0.83056,0.55693}, {-0.91594,0.40132}, {0.19989,0.97982}, {0.04442,-0.99901}, {0.94794,0.31845}, {0.80345,0.59537},
	{0.83346,-0.55258}, {-0.97929,0.20245}, {0.21013,-0.97767}, {0.61410,-0.78922}, {-0.41325,-0.91062}, {-0.09135,0.99582},
	{-0.80033,-0.59956}, {-0.33574,-0.94196}, {-0.96187,-0.27352}, {0.59747,0.80189}, {-0.99889,-0.04703}, {-0.71902,-0.69499},
	{-0.99889,0.04703}, {0.73693,0.67596}, {-0.99999,0.00523}, {-0.65844,-0.75263}, {-0.98516,-0.17165}, {0.45562,0.89017},
	{-0.88414,-0.46721}, {-0.09135,-0.99582}, {-0.59327,-0.80500}, {-0.41325,0.91062}, {-0.04964,-0.99877}, {0.88169,-0.47183},
	{0.62232,-0.78276}, {-0.95594,-0.29357}, {0.99913,-0.04181}, {0.34066,0.94019}, {0.58057,0.81421}, {0.65450,-0.75606},
	{-0.48788,0.87291}, {-0.94283,-0.33327}, {-0.97929,-0.20245}, {-0.10176,0.99481}, {0.03397,-0.99942}, {1.00000,0.00000} }
};

/* CRC16 reversal look-up table, generate by polynomial(0x11021) */
uint16_t g_crc16_table[LENGTH_CRC16_TABLE] = {
    0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
    0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
    0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
    0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
    0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
    0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
    0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
    0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
    0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
    0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
    0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
    0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
    0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
    0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
    0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
    0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
    0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
    0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
    0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
    0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
    0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
    0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
    0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
    0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
    0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
    0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
    0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
    0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
    0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
    0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
    0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
    0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};

/* CRC24A look-up table, generate by polynomial(0x1864CFB) */
uint32_t g_crc24a_table[LENGTH_CRC24A_TABLE] = {
	0,8801531,9098509,825846,9692897,1419802,1651692,10452759,
	10584377,2608578,2839604,11344079,3303384,11807523,12104405,4128302,
	12930697,4391538,5217156,13227903,5679208,13690003,14450021,5910942,
	6606768,14844747,15604413,6837830,16197969,7431594,8256604,16494759,
	840169,9084178,8783076,18463,10434312,1670131,1434117,9678590,
	11358416,2825259,2590173,10602790,4109873,12122826,11821884,3289031,
	13213536,5231515,4409965,12912278,5929345,14431610,13675660,5693559,
	6823513,15618722,14863188,6588335,16513208,8238147,7417269,16212302,
	1680338,10481449,9664223,1391140,9061683,788936,36926,8838341,
	12067563,4091408,3340262,11844381,2868234,11372785,10555655,2579964,
	14478683,5939616,5650518,13661357,5180346,13190977,12967607,4428364,
	8219746,16457881,16234863,7468436,15633027,6866552,6578062,14816117,
	1405499,9649856,10463030,1698765,8819930,55329,803287,9047340,
	11858690,3325945,4072975,12086004,2561507,10574104,11387118,2853909,
	13647026,5664841,5958079,14460228,4446803,12949160,13176670,5194661,
	7454091,16249200,16476294,8201341,14834538,6559633,6852199,15647388,
	3360676,11864927,12161705,4185682,10527045,2551230,2782280,11286707,
	9619101,1346150,1577872,10379115,73852,8875143,9172337,899466,
	16124205,7357910,8182816,16421083,6680524,14918455,15678145,6911546,
	5736468,13747439,14507289,5968354,12873461,4334094,5159928,13170435,
	4167245,12180150,11879232,3346363,11301036,2767959,2532769,10545498,
	10360692,1596303,1360505,9604738,913813,9157998,8856728,92259,
	16439492,8164415,7343561,16138546,6897189,15692510,14936872,6662099,
	5986813,14488838,13733104,5750795,13156124,5174247,4352529,12855018,
	2810998,11315341,10498427,2522496,12124823,4148844,3397530,11901793,
	9135439,862644,110658,8912057,1606574,10407765,9590435,1317464,
	15706879,6940164,6651890,14889737,8145950,16384229,16161043,7394792,
	5123014,13133629,12910283,4370992,14535975,5997020,5707818,13718737,
	2504095,10516836,11329682,2796649,11916158,3383173,4130419,12143240,
	8893606,129117,876971,9121104,1331783,9576124,10389322,1625009,
	14908182,6633453,6925851,15721184,7380471,16175372,16402682,8127489,
	4389423,12891860,13119266,5137369,13704398,5722165,6015427,14517560
};

/* CRC24A polynomial(0x1864CFB) */
uint8_t g_crc24aPoly[LENGTH_CRC24A_POLY] = {1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,1,1,0,1,1};
uint8_t g_crc24aPolyXorBit[LENGTH_DECODE_OUT_BIT] = { 0 };
uint8_t g_crc24aPolyXorOutBit[LENGTH_DECODE_OUT_BIT] = { 0 };


/* main */
int32_t PadBurstProcessing(uint64_t *inputData, uint32_t dataLength, DroneID_Signal_t *droneID)
{
	struct timespec tCur1, tCur2, tCur3, tCur4, tCur5, tCur6, tCur7, tCur8, tCur9;
	struct timespec tEnd1, tEnd2, tEnd3, tEnd4, tEnd5, tEnd6, tEnd7, tEnd8, tEnd9;
	int tUsed1 = 0, tUsed2 = 0, tUsed3 = 0, tUsed4 = 0, tUsed5 = 0, tUsed6 = 0, tUsed7 = 0, tUsed8 = 0, tUsed9 = 0;
    int32_t bIdx = 0;
    int32_t startOffset = 0, startOffset2 = 0;
    int32_t numDroneID = 0;

	clock_gettime(CLOCK_MONOTONIC, &tCur1);
	/* 1. Parse the current burst data */
	ParseBurstData(inputData, g_padBurst, g_padBurst2, dataLength);
	/* Compensate frequence offset */
	CompFreqOffset(g_padBurst, LENGTH_PADDED_BURST);
	CompFreqOffset(g_padBurst2, LENGTH_PADDED_BURST);
	clock_gettime(CLOCK_MONOTONIC, &tEnd1);
	tUsed1 = (tEnd1.tv_sec - tCur1.tv_sec) * 1000000 + (tEnd1.tv_nsec - tCur1.tv_nsec) / 1000;

	clock_gettime(CLOCK_MONOTONIC, &tCur2);
	/* Apply low pass filter */
//	LowPassFiltering(g_padBurst);
	/* 2. Find the true starting time offset based on the cyclic prefix */
//	startOffset = FindSTO(g_padBurst);
//	startOffset2 = FindSTO(g_padBurst2);
	startOffset = FindStoCpOpt1(g_padBurst, g_cpCorrScores);
	startOffset2 = FindStoCpOpt1(g_padBurst2, g_cpCorrScores2);
	clock_gettime(CLOCK_MONOTONIC, &tEnd2);
	tUsed2 = (tEnd2.tv_sec - tCur2.tv_sec) * 1000000 + (tEnd2.tv_nsec - tCur2.tv_nsec) / 1000;

	clock_gettime(CLOCK_MONOTONIC, &tCur3);
	/* 3. Coarse frequency offset adjustment using one of the OFDM symbols */
//	CompCoarseCFO(g_padBurst, startOffset, LENGTH_PADDED_BURST);
//	CompCoarseCFO(g_padBurst2, startOffset2, LENGTH_PADDED_BURST);
	CompCoarseCfoMutiCp(g_padBurst, g_cpCorrScores, startOffset, LENGTH_PADDED_BURST);
	CompCoarseCfoMutiCp(g_padBurst2, g_cpCorrScores2, startOffset2, LENGTH_PADDED_BURST);
	clock_gettime(CLOCK_MONOTONIC, &tEnd3);
	tUsed3 = (tEnd3.tv_sec - tCur3.tv_sec) * 1000000 + (tEnd3.tv_nsec - tCur3.tv_nsec) / 1000;

	clock_gettime(CLOCK_MONOTONIC, &tCur4);
	/* 4. Convert time domain symbols into subcarrier data (SC) using FFT */
	ScDataRecovery(g_padBurst, startOffset, g_scBuff);
	ScDataRecovery(g_padBurst2, startOffset2, g_scBuff2);
	clock_gettime(CLOCK_MONOTONIC, &tEnd4);
	tUsed4 = (tEnd4.tv_sec - tCur4.tv_sec) * 1000000 + (tEnd4.tv_nsec - tCur4.tv_nsec) / 1000;

	clock_gettime(CLOCK_MONOTONIC, &tCur5);
	/* 5. perform channel equalization */
//	ChEqualizer(g_scBuff, g_dataScBuff);
//	ChEqualizerMvAvg(g_scBuff, g_dataScBuff);
//	MimoMaxRatioComb(g_scBuff, g_scBuff2, g_dataScBuff);
	MimoMaxRatioCombV1(g_scBuff, g_scBuff2, g_dataScBuff);
	CalcEvm(g_dataScBuff, &g_evm);
	clock_gettime(CLOCK_MONOTONIC, &tEnd5);
	tUsed5 = (tEnd5.tv_sec - tCur5.tv_sec) * 1000000 + (tEnd5.tv_nsec - tCur5.tv_nsec) / 1000;

	clock_gettime(CLOCK_MONOTONIC, &tCur6);
	/* 6. Perform deMapping */
//	DeMapping(g_dataScBuff, g_deMapOut);
	SoftDeMapping(g_dataScBuff, g_qpskDeMapLogOut);
	clock_gettime(CLOCK_MONOTONIC, &tEnd6);
	tUsed6 = (tEnd6.tv_sec - tCur6.tv_sec) * 1000000 + (tEnd6.tv_nsec - tCur6.tv_nsec) / 1000;

	clock_gettime(CLOCK_MONOTONIC, &tCur7);
	/* 7. Perform descrambling */
//	DeScrambler(g_scrSeq, g_LFSR1, g_LFSR2, g_deMapOut);
	SoftDeScrambler(g_scrSeq, g_LFSR1, g_LFSR2, g_qpskDeMapLogOut, g_deMapOut);
	clock_gettime(CLOCK_MONOTONIC, &tEnd7);
	tUsed7 = (tEnd7.tv_sec - tCur7.tv_sec) * 1000000 + (tEnd7.tv_nsec - tCur7.tv_nsec) / 1000;

	clock_gettime(CLOCK_MONOTONIC, &tCur8);
	/* 8. Turbo decoding process(including rate matching) */
	TurboDecProcess(g_deMapOut, g_decodeOut);
	clock_gettime(CLOCK_MONOTONIC, &tEnd8);
	tUsed8 = (tEnd8.tv_sec - tCur8.tv_sec) * 1000000 + (tEnd8.tv_nsec - tCur8.tv_nsec) / 1000;

	clock_gettime(CLOCK_MONOTONIC, &tCur9);
	/* 9. Deframe process */
	DeFrame(g_decodeOut, droneID, bIdx);
	clock_gettime(CLOCK_MONOTONIC, &tEnd9);
	tUsed9 = (tEnd9.tv_sec - tCur9.tv_sec) * 1000000 + (tEnd9.tv_nsec - tCur9.tv_nsec) / 1000;

	if (PRINT_BURST_PROCESS_TIME_COST == GetAlgDebugPrintMode())
	{
		printf("burst process timeCost: %dus\r\n",
				tUsed1 + tUsed2 + tUsed3 + tUsed4 + tUsed5 + tUsed6 + tUsed7 + tUsed8 + tUsed9);
		printf("1: %dus,  2: %dus,  3: %dus,  4: %dus,  5: %dus,  6: %dus,  7: %dus,  8: %dus,  9: %dus\r\n",
				tUsed1, tUsed2, tUsed3, tUsed4, tUsed5, tUsed6, tUsed7, tUsed8, tUsed9);
	}

	numDroneID = 1;
	return numDroneID;
}

int32_t PadBurstProcessingNew(uint64_t *inputData, uint32_t dataLength, DroneID_Signal_t *droneID)
{
	struct timespec tCur1, tCur2, tCur3, tCur4, tCur5, tCur6, tCur7, tCur8, tCur9;
	struct timespec tEnd1, tEnd2, tEnd3, tEnd4, tEnd5, tEnd6, tEnd7, tEnd8, tEnd9;
	int tUsed1 = 0, tUsed2 = 0, tUsed3 = 0, tUsed4 = 0, tUsed5 = 0, tUsed6 = 0, tUsed7 = 0, tUsed8 = 0, tUsed9 = 0;
    int32_t bIdx = 0;
    int32_t startOffset = 0, startOffset2 = 0;
    int32_t numDroneID = 0;

	clock_gettime(CLOCK_MONOTONIC, &tCur1);
	/* 1. Parse the current burst data */
	ParseBurstDataNew(inputData, g_padBurst, g_padBurst2, dataLength);
	/* Compensate frequence offset */
	CompFreqOffset(g_padBurst, LENGTH_PADDED_BURST);
	CompFreqOffset(g_padBurst2, LENGTH_PADDED_BURST);
	clock_gettime(CLOCK_MONOTONIC, &tEnd1);
	tUsed1 = (tEnd1.tv_sec - tCur1.tv_sec) * 1000000 + (tEnd1.tv_nsec - tCur1.tv_nsec) / 1000;

	clock_gettime(CLOCK_MONOTONIC, &tCur2);
	/* Apply low pass filter */
//	LowPassFiltering(g_padBurst);
	/* 2. Find the true starting time offset based on the cyclic prefix */
//	startOffset = FindSTO(g_padBurst);
//	startOffset2 = FindSTO(g_padBurst2);
	startOffset = FindStoCpOpt1(g_padBurst, g_cpCorrScores);
	startOffset2 = FindStoCpOpt1(g_padBurst2, g_cpCorrScores2);
	clock_gettime(CLOCK_MONOTONIC, &tEnd2);
	tUsed2 = (tEnd2.tv_sec - tCur2.tv_sec) * 1000000 + (tEnd2.tv_nsec - tCur2.tv_nsec) / 1000;

	clock_gettime(CLOCK_MONOTONIC, &tCur3);
	/* 3. Coarse frequency offset adjustment using one of the OFDM symbols */
//	CompCoarseCFO(g_padBurst, startOffset, LENGTH_PADDED_BURST);
//	CompCoarseCFO(g_padBurst2, startOffset2, LENGTH_PADDED_BURST);
	CompCoarseCfoMutiCp(g_padBurst, g_cpCorrScores, startOffset, LENGTH_PADDED_BURST);
	CompCoarseCfoMutiCp(g_padBurst2, g_cpCorrScores2, startOffset2, LENGTH_PADDED_BURST);
	clock_gettime(CLOCK_MONOTONIC, &tEnd3);
	tUsed3 = (tEnd3.tv_sec - tCur3.tv_sec) * 1000000 + (tEnd3.tv_nsec - tCur3.tv_nsec) / 1000;

	clock_gettime(CLOCK_MONOTONIC, &tCur4);
	/* 4. Convert time domain symbols into subcarrier data (SC) using FFT */
	ScDataRecovery(g_padBurst, startOffset, g_scBuff);
	ScDataRecovery(g_padBurst2, startOffset2, g_scBuff2);
	clock_gettime(CLOCK_MONOTONIC, &tEnd4);
	tUsed4 = (tEnd4.tv_sec - tCur4.tv_sec) * 1000000 + (tEnd4.tv_nsec - tCur4.tv_nsec) / 1000;

	clock_gettime(CLOCK_MONOTONIC, &tCur5);
	/* 5. perform channel equalization */
//	ChEqualizer(g_scBuff, g_dataScBuff);
//	ChEqualizerMvAvg(g_scBuff, g_dataScBuff);
//	MimoMaxRatioComb(g_scBuff, g_scBuff2, g_dataScBuff);
	MimoMaxRatioCombV1(g_scBuff, g_scBuff2, g_dataScBuff);
	CalcEvm(g_dataScBuff, &g_evm);
	clock_gettime(CLOCK_MONOTONIC, &tEnd5);
	tUsed5 = (tEnd5.tv_sec - tCur5.tv_sec) * 1000000 + (tEnd5.tv_nsec - tCur5.tv_nsec) / 1000;

	clock_gettime(CLOCK_MONOTONIC, &tCur6);
	/* 6. Perform deMapping */
//	DeMapping(g_dataScBuff, g_deMapOut);
//	SoftDeMapping(g_dataScBuff, g_qpskDeMapLogOut);
	SoftDeMappingNormFactor(g_dataScBuff, g_normalizedFactor, g_qpskDeMapLogOut);
	clock_gettime(CLOCK_MONOTONIC, &tEnd6);
	tUsed6 = (tEnd6.tv_sec - tCur6.tv_sec) * 1000000 + (tEnd6.tv_nsec - tCur6.tv_nsec) / 1000;

	clock_gettime(CLOCK_MONOTONIC, &tCur7);
	/* 7. Perform descrambling */
//	DeScrambler(g_scrSeq, g_LFSR1, g_LFSR2, g_deMapOut);
	SoftDeScrambler(g_scrSeq, g_LFSR1, g_LFSR2, g_qpskDeMapLogOut, g_deMapOut);
	clock_gettime(CLOCK_MONOTONIC, &tEnd7);
	tUsed7 = (tEnd7.tv_sec - tCur7.tv_sec) * 1000000 + (tEnd7.tv_nsec - tCur7.tv_nsec) / 1000;

	clock_gettime(CLOCK_MONOTONIC, &tCur8);
	/* 8. Turbo decoding process(including rate matching) */
	TurboDecProcess(g_deMapOut, g_decodeOut);
	clock_gettime(CLOCK_MONOTONIC, &tEnd8);
	tUsed8 = (tEnd8.tv_sec - tCur8.tv_sec) * 1000000 + (tEnd8.tv_nsec - tCur8.tv_nsec) / 1000;

	clock_gettime(CLOCK_MONOTONIC, &tCur9);
	/* 9. Deframe process */
	DeFrame(g_decodeOut, droneID, bIdx);
	clock_gettime(CLOCK_MONOTONIC, &tEnd9);
	tUsed9 = (tEnd9.tv_sec - tCur9.tv_sec) * 1000000 + (tEnd9.tv_nsec - tCur9.tv_nsec) / 1000;

	if (PRINT_BURST_PROCESS_TIME_COST == GetAlgDebugPrintMode())
	{
		printf("burst process timeCost: %dus\r\n",
				tUsed1 + tUsed2 + tUsed3 + tUsed4 + tUsed5 + tUsed6 + tUsed7 + tUsed8 + tUsed9);
		printf("1: %dus,  2: %dus,  3: %dus,  4: %dus,  5: %dus,  6: %dus,  7: %dus,  8: %dus,  9: %dus\r\n",
				tUsed1, tUsed2, tUsed3, tUsed4, tUsed5, tUsed6, tUsed7, tUsed8, tUsed9);
	}

	numDroneID = 1;
	return numDroneID;
}


/* parse Burst data from dma */
void ParseBurstData(uint64_t *inputData, Cplxf_t *padBurst, Cplxf_t *padBurst2, uint32_t dataLength)
{
	int32_t i = 0, j = 0;
	int16_t real = 0, imag = 0;
	int16_t real1 = 0, imag1 = 0;

	for (i = 0; i < dataLength; i++)
	{
		real = inputData[i] & ADC_REAL_MASK;
		imag = (inputData[i] >> ADC_IMAG_OFFSET) & ADC_IMAG_MASK;
		real1 = (inputData[i] >> (ADC_IMAG_OFFSET * 2)) & ADC_REAL_MASK;
		imag1 = (inputData[i] >> (ADC_IMAG_OFFSET * 3)) & ADC_IMAG_MASK;

		if (real > ADC_DATA_MAX)
		{
			real -= ADC_DATA_BIT_SCOPE;
		}
		if (imag > ADC_DATA_MAX)
		{
			imag -= ADC_DATA_BIT_SCOPE;
		}
		if (real1 > ADC_DATA_MAX)
		{
			real1 -= ADC_DATA_BIT_SCOPE;
		}
		if (imag1 > ADC_DATA_MAX)
		{
			imag1 -= ADC_DATA_BIT_SCOPE;
		}

		padBurst[j].re = (float)real;
		padBurst[j].im = (float)imag;
		padBurst2[j].re = (float)real1;
		padBurst2[j].im = (float)imag1;

		j++;
	}
}

/* parse Burst data from dma, new protocol, length = 19980 */
void ParseBurstDataNew(uint64_t *inputData, Cplxf_t *padBurst, Cplxf_t *padBurst2, uint32_t dataLength)
{
	int32_t i = 0, j = 0;
	int16_t real = 0, imag = 0;
	int16_t real1 = 0, imag1 = 0;

//	BurstDataCheck(inputData);

	for (i = 0; i < LENGTH_PADDED_BURST; i++)
	{
		real = inputData[i + 3] & ADC_REAL_MASK;
		imag = (inputData[i + 3] >> ADC_IMAG_OFFSET) & ADC_IMAG_MASK;
		real1 = (inputData[i + 3] >> (ADC_IMAG_OFFSET * 2)) & ADC_REAL_MASK;
		imag1 = (inputData[i + 3] >> (ADC_IMAG_OFFSET * 3)) & ADC_IMAG_MASK;

		if (real > ADC_DATA_MAX)
		{
			real -= ADC_DATA_BIT_SCOPE;
		}
		if (imag > ADC_DATA_MAX)
		{
			imag -= ADC_DATA_BIT_SCOPE;
		}
		if (real1 > ADC_DATA_MAX)
		{
			real1 -= ADC_DATA_BIT_SCOPE;
		}
		if (imag1 > ADC_DATA_MAX)
		{
			imag1 -= ADC_DATA_BIT_SCOPE;
		}

		padBurst[j].re = (float)real;
		padBurst[j].im = (float)imag;
		padBurst2[j].re = (float)real1;
		padBurst2[j].im = (float)imag1;

		j++;
	}
}


/* compensate frequence offset */
void CompFreqOffset(Cplxf_t *padBurst, uint32_t burstLength)
{
	int32_t i = 0;
	Cplxf_t a = { 0.0f }, b = { 0.0f }, c = { 0.0f };
	float freqOffset = 0.0f;
	float freqOffsetConstant = 0.0f;

	freqOffset = (float)(GetFreqOffsetHz());
	freqOffsetConstant = DOUBLE_PI_VALUE * (-1 * freqOffset / DEFAULT_SAMPLE_RATE);

	for (i = 0; i < burstLength; i++)
	{
		a.re = cosf(freqOffsetConstant * (i + 1));
		a.im = sinf(freqOffsetConstant * (i + 1));
		b.re = padBurst[i].re;
		b.im = padBurst[i].im;
		c.re = ((a.re * b.re) - (a.im * b.im));
		c.im = ((a.re * b.im) + (a.im * b.re));
		padBurst[i] = c;
	}
}


/* Low pass filter */
void LowPassFiltering(Cplxf_t *padBurst)
{
	int32_t i = 0;
	int32_t j = 0;
	/* sample_rate = 30.72MHz, signal_bandwidth = 12MHz */
	float b[NUM_FILTER_TAP + 1] = {-0.000685171750530239,-0.00102640126912736,6.42455355916594e-05,
			0.00155746449212579,0.00123814973491346,-0.00148662451978744,-0.00333166283635524,
			-0.000428463218232170,0.00497641863988345,0.00484917017590006,-0.00361566259453739,
			-0.0102851322822149,-0.00304587871503423,0.0125676450190746,0.0145784143324112,
			-0.00631346724953211,-0.0260371634869052,-0.0119950720918207,0.0281199112752665,
			0.0410216858401391,-0.00853455470980468,-0.0737288589770011,-0.0528729412536384,
			0.0996716849338060,0.299107858247338,0.391268813456142,0.299107858247338,
			0.0996716849338060,-0.0528729412536384,-0.0737288589770011,-0.00853455470980468,
			0.0410216858401391,0.0281199112752665,-0.0119950720918207,-0.0260371634869052,
			-0.00631346724953211,0.0145784143324112,0.0125676450190746,-0.00304587871503423,
			-0.0102851322822149,-0.00361566259453739,0.00484917017590006,0.00497641863988345,
			-0.000428463218232170,-0.00333166283635524,-0.00148662451978744,0.00123814973491346,
			0.00155746449212579,6.42455355916594e-05,-0.00102640126912736,-0.000685171750530239};

	for (i = 0; i < LENGTH_PADDED_BURST; i++)
	{
		g_y1r[NUM_FILTER_TAP + i] = padBurst[i].re;
		g_y1i[NUM_FILTER_TAP + i] = padBurst[i].im;
	}

	for (i = NUM_FILTER_TAP; i < LENGTH_PADDED_BURST + NUM_FILTER_TAP; i++)
	{
		g_y2r[i] = b[0] * g_y1r[i];
		g_y2i[i] = b[0] * g_y1i[i];
		for (j = 1; j < (NUM_FILTER_TAP + 1); j++)
		{
			g_y2r[i] = g_y2r[i] + b[j] * g_y1r[i - j];
			g_y2i[i] = g_y2i[i] + b[j] * g_y1i[i - j];
		}
	}

	for (i = 0; i < LENGTH_PADDED_BURST; i++)
	{
	   padBurst[i].re = g_y2r[NUM_FILTER_TAP + i];
	   padBurst[i].im = g_y2i[NUM_FILTER_TAP + i];
	}
}


/* find STO */
int32_t FindSTO(Cplxf_t *padBurst)
{
	int32_t tt = 0, ss = 0;
	int32_t numTests = NUM_PADDING_SAMPLE;
	float scoreTtl = { 0.0f }, scoreCurr = { 0.0f };
	float maxScore = 0.0f;
	uint32_t cpLength = 0;
	int32_t startOffset = 0;
	int32_t idxCP = 0, idxTail = 0;
	int32_t offset = 0;
	Cplxf_t result = { 0.0f };

	/* Evaluate the best STO through all the tests */
	for (tt = 0; tt < numTests; tt++)
	{
		scoreTtl = 0.0f;
		offset = 0;

		/* Accumlate the scores of 8 OFDM symbos (skip 1st symbol) */
		for (ss = 0; ss < NUM_SYMBOL_PER_BURST; ss++)
		{
			if ((ss == 0) || (ss == NUM_SYMBOL_PER_BURST - 1))
			{
				cpLength = LENGTH_LONG_CP;
			}
			else
			{
				cpLength = LENGTH_SHORT_CP;
			}

			/* Find score for the current symbol*/
			idxCP = tt + offset;
			idxTail = tt + SIZE_FFT + offset;

			if (ss == 0)
			{
				scoreCurr = 0.0;
			}
			else
			{
				result = InnerProductFloat(&padBurst[idxCP], &padBurst[idxTail], cpLength);
				scoreCurr = result.re*result.re + result.im*result.im;
			}

			scoreTtl += scoreCurr;

			offset += cpLength + SIZE_FFT;
		}

		if (scoreTtl > maxScore)
		{
			maxScore = scoreTtl;
			startOffset = tt;
		}
	}

	return startOffset;
}

/* find STO */
int32_t FindStoCpOpt1(Cplxf_t *padBurst, Cplxf_t *cpCorrScores)
{
	int32_t tt = 0, ss = 0;
	int32_t numTests = NUM_PADDING_SAMPLE;
	float scoreTtl = { 0.0f }, scoreCurr = { 0.0f };
	float maxScore = 0.0f;
	uint32_t cpLength = 0;
	int32_t startOffset = 0;
	int32_t idxCP = 0, idxTail = 0;
	int32_t offset = 0;
	Cplxf_t result = { 0.0f };

	/* Evaluate the best STO through all the tests */ 
	for (tt = 0; tt < numTests; tt++)
	{
		scoreTtl = 0.0f;
		offset = 0;
		
		/* Accumlate the scores of 8 OFDM symbos (skip 1st symbol) */
		for (ss = 0; ss < NUM_SYMBOL_PER_BURST; ss++)
		{
			result.re = 0.0f;
			result.im = 0.0f;

			if ((ss == 0) || (ss == NUM_SYMBOL_PER_BURST - 1))
			{
				cpLength = LENGTH_LONG_CP;          
			}
			else
			{
				cpLength = LENGTH_SHORT_CP;
			}

			/* Find score for the current symbol*/
			idxCP = tt + offset; 
			idxTail = tt + SIZE_FFT + offset;

			if (ss == 0)
			{
				scoreCurr = 0.0;
			}
			else
			{
				result = InnerProductFloat(&padBurst[idxCP], &padBurst[idxTail], cpLength);
				scoreCurr = result.re*result.re + result.im*result.im;
			}
			
			cpCorrScores[tt * NUM_SYMBOL_PER_BURST + ss].re = result.re;
			cpCorrScores[tt * NUM_SYMBOL_PER_BURST + ss].im = result.im;

			scoreTtl += scoreCurr; 

			offset += cpLength + SIZE_FFT;
		}

		if (scoreTtl > maxScore)
		{
			maxScore = scoreTtl;
			startOffset = tt;
		}
	}

	return startOffset;
} 


/* Compensate coarse CFO */
void CompCoarseCFO(Cplxf_t *padBurst, int32_t sto, uint32_t length)
{
	int ii = 0;
	uint32_t zcStartIdx = 0u;
	Cplxf_t padBurstTmp = { 0.0f };
	Cplxf_t result = { 0.0f };
	float coarseCFO = 0.0f;
	float coarseCFO_cosf = 0.0f;
	float coarseCFO_sinf = 0.0f;

	/* Calculate coarse CFO */
	zcStartIdx = sto + LENGTH_LONG_CP + 2*LENGTH_SHORT_CP + 3*SIZE_FFT;
	result = InnerProductFloat(&padBurst[zcStartIdx+SIZE_FFT], &padBurst[zcStartIdx], LENGTH_SHORT_CP);
	coarseCFO = (float)atan2f(result.im, result.re) / SIZE_FFT;

	/* Compensate CFO */
	for (ii = sto; ii < length; ii++)
	{
		padBurstTmp = padBurst[ii];
		coarseCFO_cosf = cosf(-(ii-sto+1)*coarseCFO);
		coarseCFO_sinf = sinf(-(ii-sto+1)*coarseCFO);
		padBurst[ii].re = padBurstTmp.re*coarseCFO_cosf - padBurstTmp.im*coarseCFO_sinf;
		padBurst[ii].im = padBurstTmp.re*coarseCFO_sinf + padBurstTmp.im*coarseCFO_cosf;
	}
}

/* Compensate coarse CFO */
void CompCoarseCfoMutiCp(Cplxf_t *padBurst, Cplxf_t *cpCorrScores, int32_t sto, uint32_t length)
{
	int ii = 0;
	Cplxf_t padBurstTmp = { 0.0f };
	Cplxf_t cpCorrScoresSto = { 0.0f };
	float coarseCFO = 0.0f;
	float coarseCFO_cosf = 0.0f;
	float coarseCFO_sinf = 0.0f;
	float offset_radians = 0.0f, offset_radians_sum = 0.0f;

	/* mean(-angle(CP_Corr_Scroes(true_start_index,2:end))) / fft_size */
	for (ii = 1; ii < NUM_SYMBOL_PER_BURST; ii++)
	{
		cpCorrScoresSto.re = cpCorrScores[sto * NUM_SYMBOL_PER_BURST + ii].re;
		cpCorrScoresSto.im = cpCorrScores[sto * NUM_SYMBOL_PER_BURST + ii].im;
		offset_radians = -(float)(atan2f(cpCorrScoresSto.im, cpCorrScoresSto.re));
		offset_radians_sum += offset_radians;
	}
	coarseCFO = offset_radians_sum / (NUM_SYMBOL_PER_BURST - 1) / SIZE_FFT;

	/* Compensate CFO */
	for (ii = sto; ii < length; ii++)
	{
		padBurstTmp = padBurst[ii];
		coarseCFO_cosf = cosf(-(ii-sto+1)*coarseCFO);
		coarseCFO_sinf = sinf(-(ii-sto+1)*coarseCFO);
		padBurst[ii].re = padBurstTmp.re*coarseCFO_cosf - padBurstTmp.im*coarseCFO_sinf;
		padBurst[ii].im = padBurstTmp.re*coarseCFO_sinf + padBurstTmp.im*coarseCFO_cosf;
	}
}


/* subcarrier data recovery */
void ScDataRecovery(Cplxf_t *padBurst, int32_t sto, Cplxf_t *scBuff)
{
	int ii = 0, jj = 0;
	uint32_t offset = 0u;
	uint32_t cpLength = 0u;
	
	if (!g_initFlag)
	{
		tw_gen(g_w_sp, SIZE_FFT);
		g_initFlag = true;
	}

	/* Recover subcarriers for all symbols excluding the 1st symbol */
	for (ii = 0; ii < NUM_SYMBOL_PER_BURST; ii++)
	{
		/* Update the offset */
		if ((ii == 0) || (ii == 8))
		{
			cpLength = LENGTH_LONG_CP;
		}
		else
		{
			cpLength = LENGTH_SHORT_CP;
		}
		
		if (ii != 0)
		{
			/* Remove CP of each symbol */
			memcpy((void*)g_currTimeData, (void*)&padBurst[sto+offset+cpLength], SIZE_FFT * sizeof(Cplxf_t));

if(flag_debug_fft_dma)
{
			/* FFT processing */
			for (jj = 0; jj < SIZE_FFT; jj++)
			{
				g_x_sp[2*jj  ] = g_currTimeData[jj].re;
				g_x_sp[2*jj+1] = g_currTimeData[jj].im;
			}

//			DSPF_sp_fftSPxSP_cn(SIZE_FFT, g_x_sp, g_w_sp, g_y_sp, 2, 0, SIZE_FFT);
			DSPF_sp_PL_fftSPxSP_cn(g_x_sp, g_y_sp);

			for (jj = 0; jj < SIZE_FFT; jj++)
			{
				g_currFreqData[jj].re = g_y_sp[2*jj  ];
				g_currFreqData[jj].im = g_y_sp[2*jj+1];
			}

			/* Output to subcarrier buffer (fftshift) */
			memcpy((void*)&scBuff[ii * SIZE_FFT], (void*)&g_currFreqData[(SIZE_FFT >> 1)], (SIZE_FFT >> 1) * sizeof(Cplxf_t));
			memcpy((void*)&scBuff[ii * SIZE_FFT + (SIZE_FFT >> 1)], (void*)&g_currFreqData[0], (SIZE_FFT >> 1)* sizeof(Cplxf_t));
} else {
			fft(g_currTimeData, SIZE_FFT);
			memcpy((void*)&scBuff[ii * SIZE_FFT], (void*)&g_currTimeData[(SIZE_FFT >> 1)], (SIZE_FFT >> 1) * sizeof(Cplxf_t));
			memcpy((void*)&scBuff[ii * SIZE_FFT + (SIZE_FFT >> 1)], (void*)&g_currTimeData[0], (SIZE_FFT >> 1)* sizeof(Cplxf_t));
}
		}
		
		offset += (cpLength + SIZE_FFT);
	}
}


/* channel equalization */
void ChEqualizer(Cplxf_t *scBuff, Cplxf_t *dataScBuff)
{
	int symIdx = 0;
	int ii = 0;
	int offsetIn = 0;
	int offsetOut = 0;
	Cplxf_t rxDataTmp = { 0.0f };
	Cplxf_t *chEst = NULL;

	/* channel estimaiton using the 1st ZC seq. */
	memcpy((void*)&g_rxData[0],   (void*)&scBuff[3*SIZE_FFT + ((SIZE_FFT/2) - (NUM_DATA_CARRIER/2))], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	memcpy((void*)&g_rxData[300], (void*)&scBuff[3*SIZE_FFT + ((SIZE_FFT/2) + 1)], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	CalcChannelZcSnr(g_rxData, 0, g_zcSnr);
	EstimateChannel(g_rxData, g_chEst1);

	/* channel estimaiton using the 2nd ZC seq. */
	memcpy((void*)&g_rxData[0],   (void*)&scBuff[5*SIZE_FFT + ((SIZE_FFT/2) - (NUM_DATA_CARRIER/2))], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	memcpy((void*)&g_rxData[300], (void*)&scBuff[5*SIZE_FFT + ((SIZE_FFT/2) + 1)], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	CalcChannelZcSnr(g_rxData, 1, g_zcSnr);
	EstimateChannel(g_rxData, g_chEst2);

	for (ii = 0; ii < NUM_DATA_CARRIER; ii++)
	{
		g_chEst5[ii].re = (g_chEst1[ii].re + g_chEst2[ii].re) / 2;
		g_chEst5[ii].im = (g_chEst1[ii].im + g_chEst2[ii].im) / 2;
	}

	/* channel equalization for "valid" subcarrier data (i.e., 600 SCs) */
	for (symIdx = 0; symIdx < NUM_SYMBOL_PER_BURST; symIdx++)
	{	
		if ((symIdx != 0) && (symIdx != 3) && (symIdx != 5))
		{
			/* Obtain the current symbol */
			memcpy((void*)&g_rxData[0],   (void*)&scBuff[offsetIn + ((SIZE_FFT/2) - (NUM_DATA_CARRIER/2))], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
			memcpy((void*)&g_rxData[300], (void*)&scBuff[offsetIn + ((SIZE_FFT/2) + 1)], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));

			/* Do channel equalization */
			if (symIdx < 4)
			{
				chEst = &g_chEst1[0];
			}
			else if (symIdx == 4)
			{
				chEst = &g_chEst1[0];
			}
			else
			{
				chEst = &g_chEst1[0];
			}
			for (ii = 0; ii < NUM_DATA_CARRIER; ii++)
			{
				rxDataTmp = g_rxData[ii];
				g_rxData[ii].re = (rxDataTmp.re * chEst[ii].re - rxDataTmp.im * chEst[ii].im);
				g_rxData[ii].im = (rxDataTmp.re * chEst[ii].im + rxDataTmp.im * chEst[ii].re);
			}

			/* Output to data subcarrier buffer */
			memcpy((void*)&dataScBuff[offsetOut], (void*)g_rxData, NUM_DATA_CARRIER * sizeof(Cplxf_t));

			offsetOut = offsetOut + NUM_DATA_CARRIER;
		}

		offsetIn = offsetIn + SIZE_FFT;
	}
}


/* channel estimation */
void EstimateChannel(Cplxf_t *rxData, Cplxf_t *chEst)
{
	int ii = 0;
	float invNormSquare = 0.0;

	for (ii = 0; ii < NUM_DATA_CARRIER; ii++)
	{
		invNormSquare = 1.0 / (rxData[ii].re*rxData[ii].re + rxData[ii].im*rxData[ii].im);

		chEst[ii].re =  g_zcData[0][ii].re*rxData[ii].re + g_zcData[0][ii].im*rxData[ii].im;
		chEst[ii].im = -g_zcData[0][ii].re*rxData[ii].im + g_zcData[0][ii].im*rxData[ii].re;

		chEst[ii].re = chEst[ii].re * invNormSquare;
		chEst[ii].im = chEst[ii].im * invNormSquare;
	}
}


/* channel equalization use moving average */
void ChEqualizerMvAvg(Cplxf_t *scBuff, Cplxf_t *dataScBuff)
{
	int symIdx = 0;
	int ii = 0;
	int offsetIn = 0;
	int offsetOut = 0;
	Cplxf_t rxDataTmp = { 0.0f };
	Cplxf_t *chEst = NULL;

	/* channel estimaiton using the 1st ZC seq. */
	memcpy((void*)&g_rxData[0],   (void*)&scBuff[3*SIZE_FFT + ((SIZE_FFT/2) - (NUM_DATA_CARRIER/2))], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	memcpy((void*)&g_rxData[300], (void*)&scBuff[3*SIZE_FFT + ((SIZE_FFT/2) + 1)], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	CalcChannelZcSnr(g_rxData, 0, g_zcSnr);
	EstimateChannelMvAvg(g_rxData, g_chEst1, 0, NUM_WIND_MV_AVG);

	/* channel estimaiton using the 2nd ZC seq. */
	memcpy((void*)&g_rxData[0],   (void*)&scBuff[5*SIZE_FFT + ((SIZE_FFT/2) - (NUM_DATA_CARRIER/2))], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	memcpy((void*)&g_rxData[300], (void*)&scBuff[5*SIZE_FFT + ((SIZE_FFT/2) + 1)], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	CalcChannelZcSnr(g_rxData, 1, g_zcSnr);
	EstimateChannelMvAvg(g_rxData, g_chEst2, 1, NUM_WIND_MV_AVG);

	for (ii = 0; ii < NUM_DATA_CARRIER; ii++)
	{
		g_chEst5[ii].re = (g_chEst1[ii].re + g_chEst2[ii].re) / 2;
		g_chEst5[ii].im = (g_chEst1[ii].im + g_chEst2[ii].im) / 2;
	}

	/* channel equalization for "valid" subcarrier data (i.e., 600 SCs) */
	for (symIdx = 0; symIdx < NUM_SYMBOL_PER_BURST; symIdx++)
	{
		if ((symIdx != 0) && (symIdx != 3) && (symIdx != 5))
		{
			/* Obtain the current symbol */
			memcpy((void*)&g_rxData[0],   (void*)&scBuff[offsetIn + ((SIZE_FFT/2) - (NUM_DATA_CARRIER/2))], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
			memcpy((void*)&g_rxData[300], (void*)&scBuff[offsetIn + ((SIZE_FFT/2) + 1)], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));

			/* Do channel equalization */
			if (symIdx < 4)
			{
				chEst = &g_chEst1[0];
			}
			else if (symIdx == 4)
			{
				chEst = &g_chEst5[0];
			}
			else
			{
				chEst = &g_chEst2[0];
			}
			for (ii = 0; ii < NUM_DATA_CARRIER; ii++)
			{
				rxDataTmp = g_rxData[ii];
				g_rxData[ii].re = (rxDataTmp.re * chEst[ii].re - rxDataTmp.im * chEst[ii].im);
				g_rxData[ii].im = (rxDataTmp.re * chEst[ii].im + rxDataTmp.im * chEst[ii].re);
			}

			/* Output to data subcarrier buffer */
			memcpy((void*)&dataScBuff[offsetOut], (void*)g_rxData, NUM_DATA_CARRIER * sizeof(Cplxf_t));

			offsetOut = offsetOut + NUM_DATA_CARRIER;
		}

		offsetIn = offsetIn + SIZE_FFT;
	}
}


/* channel estimation use moving average */
void EstimateChannelMvAvg(Cplxf_t *rxData, Cplxf_t *chEst, int32_t zcIdx, uint32_t N_wind)
{
	uint32_t ii = 0;
	uint32_t idxSt = 0, idxEd = 0;
	float invNormSquare = 0.0f;
	Cplxf_t H[NUM_DATA_CARRIER] = { { 0.0f } };
	Cplxf_t *hf_temp = NULL;

	for (ii = 0; ii < NUM_DATA_CARRIER; ii++)
	{
		invNormSquare = 1.0 / (rxData[ii].re*rxData[ii].re + rxData[ii].im*rxData[ii].im);

		H[ii].re =  g_zcData[zcIdx][ii].re*rxData[ii].re + g_zcData[zcIdx][ii].im*rxData[ii].im;
		H[ii].im = -g_zcData[zcIdx][ii].re*rxData[ii].im + g_zcData[zcIdx][ii].im*rxData[ii].re;

		H[ii].re = H[ii].re * invNormSquare;
		H[ii].im = H[ii].im * invNormSquare;
	}

	idxSt = 0;
	idxEd = ((N_wind - 1) / 2);
	for (ii = idxSt; ii < idxEd; ii++)
	{
		chEst[ii] = H[ii];
		chEst[NUM_DATA_CARRIER - (ii + 1)] = H[NUM_DATA_CARRIER - (ii + 1)];
	}

	idxSt = ((N_wind - 1) / 2);
	idxEd = (NUM_DATA_CARRIER - ((N_wind - 1) / 2));
	for (ii = idxSt; ii < idxEd; ii++)
	{
		hf_temp = &H[ii - idxSt];
		chEst[ii] = CalcCplxfVectorMean(hf_temp, N_wind);
	}
}


/* channel1 SNR calculation */
void CalcChannelZcSnr(Cplxf_t *rxData, int32_t zcIdx, float *zcSnr)
{
	uint32_t ii = 0;
	float powerSum = 0.0f, powerMean = 0.0f;
	float noiseSum = 0.0f, noiseMean = 0.0f;
	Cplxf_t Hzc1[NUM_DATA_CARRIER] = { { 0.0f } };
	Cplxf_t Hzc1Diff = { 0.0f };

	for (ii = 0; ii < NUM_DATA_CARRIER; ii++)
	{
		Hzc1[ii].re =  rxData[ii].re*g_zcData[0][ii].re + rxData[ii].im*g_zcData[0][ii].im;
		Hzc1[ii].im = -rxData[ii].re*g_zcData[0][ii].im + rxData[ii].im*g_zcData[0][ii].re;
		powerSum += (Hzc1[ii].re * Hzc1[ii].re + Hzc1[ii].im * Hzc1[ii].im);
	}
	powerMean = powerSum / NUM_DATA_CARRIER;

	for (ii = 0; ii < (NUM_DATA_CARRIER - 2); ii++)
	{
		Hzc1Diff.re  = (2 * Hzc1[ii + 1].re - Hzc1[ii].re - Hzc1[ii + 2].re);
		Hzc1Diff.im  = (2 * Hzc1[ii + 1].im - Hzc1[ii].im - Hzc1[ii + 2].im);
		noiseSum += (Hzc1Diff.re * Hzc1Diff.re + Hzc1Diff.im * Hzc1Diff.im);
	}
	noiseMean = noiseSum / (NUM_DATA_CARRIER - 2);

	zcSnr[zcIdx] = 10 * log10f(powerMean / noiseMean) + 2;
}


/* deMapping */
void DeMapping(Cplxf_t *dataScBuff, int8_t *deMapOut)
{   
	int ii = 0;
	
	for (ii = 0; ii < LENGTH_DATA_CARRIER_BUFF; ii++)
	{
		/* Decision on I data */
		if (dataScBuff[ii].re > 0)
		{
			deMapOut[ii*2] = 0;
		}
		else
		{
			deMapOut[ii*2] = 1;
		}

		/* Decision on Q data */
		if (dataScBuff[ii].im > 0)
		{
			deMapOut[ii*2 + 1] = 0;
		}
		else
		{
			deMapOut[ii*2 + 1] = 1;
		}
	}
}


/* qpsk soft deMap */
void SoftDeMapping(Cplxf_t *dataScBuff, float *deMapOut)
{
	uint32_t ii = 0;
	float SNR_Linear_MRC = 0.0f;
	float K = 0.0f;

	SNR_Linear_MRC = powf(10, (g_zcSnr[0] / 10)) + powf(10, (g_zcSnr[1] / 10));
	K = 254 / (SNR_Linear_MRC + 3 * sqrtf(SNR_Linear_MRC)) / 2;

	for (ii = 0; ii < LENGTH_DATA_CARRIER_BUFF; ii++)
	{
		deMapOut[ii * 2] 	 = -K * dataScBuff[ii].re * INV_SQRT_2 * SNR_Linear_MRC;
		deMapOut[ii * 2 + 1] = -K * dataScBuff[ii].im * INV_SQRT_2 * SNR_Linear_MRC;
	}
}

/* qpsk soft deMap use normalize factor */
void SoftDeMappingNormFactor(Cplxf_t *dataScBuff, float *pNormFactor, float *deMapOut)
{
	uint32_t ii = 0, jj = 0, dataIdx = 0;
	float SNR_Linear_MRC = 0.0f;
	float K = 0.0f;

	SNR_Linear_MRC = powf(10, (g_zcSnr[0] / 10)) + powf(10, (g_zcSnr[1] / 10));
	K = 254 / (SNR_Linear_MRC + 3 * sqrtf(SNR_Linear_MRC)) / 2;

	for (ii = 0; ii < NUM_USE_SYMBOL_PER_BURST; ii++)
	{
		for (jj = 0; jj < NUM_DATA_CARRIER; jj++)
		{
			dataIdx = ii * NUM_DATA_CARRIER + jj;
			deMapOut[dataIdx * 2] 	 = -K * dataScBuff[dataIdx].re * INV_SQRT_2 * pNormFactor[jj];
			deMapOut[dataIdx * 2 + 1] = -K * dataScBuff[dataIdx].im * INV_SQRT_2 * pNormFactor[jj];
		}
	}
}

/* descrambler */
void DeScrambler(int32_t *scrSeq, int32_t *lfsr1, int32_t *lfsr2, int8_t *deMapOut)
{    
	int32_t ii = 0;
	int32_t Nc = 1600;
	int32_t x1_init[31] = { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
	int32_t x2_init[31] = { 0,0,0,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0 };
   
	/* Inialization */
	memset((void *)lfsr1, 0, LENGTH_LFSR * sizeof(int));
	memset((void *)lfsr2, 0, LENGTH_LFSR * sizeof(int));

	/* Descrambling */
	for (ii = 0; ii < LENGTH_LFSR; ii++) 
	{
		if (ii < 31)
		{
			lfsr1[ii] = x1_init[ii];
			lfsr2[ii] = x2_init[ii];
		}
		else
		{
			lfsr1[ii] = (lfsr1[(ii-31) + 3] + lfsr1[ii-31]) % 2;
			lfsr2[ii] = (lfsr2[(ii-31) + 3] + lfsr2[(ii-31) + 2] + lfsr2[(ii-31) + 1] + lfsr2[ii-31]) % 2;
		}
	}

	for (ii = 0; ii < LENGTH_DEMAP_OUT_BIT; ii++)
	{
		scrSeq[ii] = (lfsr1[ii + Nc] + lfsr2[ii + Nc]) % 2;
		deMapOut[ii] = (scrSeq[ii] + deMapOut[ii]) % 2;
	}
}


/* soft descrambler */
void SoftDeScrambler(int32_t *scrSeq, int32_t *lfsr1, int32_t *lfsr2, float *softDeMapOut, int8_t *deMapOut)
{
	int32_t ii = 0;
	int32_t Nc = 1600;
	int32_t x1_init[31] = { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
	int32_t x2_init[31] = { 0,0,0,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0 };

	/* Inialization */
	memset((void *)lfsr1, 0, LENGTH_LFSR * sizeof(int));
	memset((void *)lfsr2, 0, LENGTH_LFSR * sizeof(int));

	/* Descrambling */
	for (ii = 0; ii < LENGTH_LFSR; ii++)
	{
		if (ii < 31)
		{
			lfsr1[ii] = x1_init[ii];
			lfsr2[ii] = x2_init[ii];
		}
		else
		{
			lfsr1[ii] = (lfsr1[(ii-31) + 3] + lfsr1[ii-31]) % 2;
			lfsr2[ii] = (lfsr2[(ii-31) + 3] + lfsr2[(ii-31) + 2] + lfsr2[(ii-31) + 1] + lfsr2[ii-31]) % 2;
		}
	}

	for (ii = 0; ii < LENGTH_DEMAP_OUT_BIT; ii++)
	{
		scrSeq[ii] = (lfsr1[ii + Nc] + lfsr2[ii + Nc]) % 2;
		if (scrSeq[ii] == 1)
		{
			softDeMapOut[ii] *= -1;
		}

		if (softDeMapOut[ii] < -63)
		{
			deMapOut[ii] = -63;
		}
		else if (softDeMapOut[ii] > 63)
		{
			deMapOut[ii] = 63;
		}
		else
		{
			deMapOut[ii] = (int8_t)roundf(softDeMapOut[ii]);
		}
	}
}


/* deframe */
void DeFrame(uint8_t *decodeOut, DroneID_Signal_t *droneID, int32_t num)
{
	int8_t byteList[NUM_FIELD_IN_PACKET] = {1, 2, 2, 2, 16, 4, 4, 2, 2, 2, 2, 2, 2, 8, 4, 4, 4, 4, 1, 1, 18, 1, 3};
	int8_t offset = 0;

	/* new drone type check(front 6 byte is 0x00) */
	for (int8_t ii = 0; ii < 6; ii++)
	{
		if (decodeOut[ii] == 0x00)
		{
			offset++;
		}
	}

	if ((offset == 0) || (offset == 6))
	{
		/* Obtain drone ID information */
		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].hex_symbol, byteList[0], 0);
		offset += byteList[0]; 

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].packet_type, byteList[1], 0);
		offset += byteList[1]; 

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].squence_num, byteList[2], 1);
		offset += byteList[2]; 

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].state_info, byteList[3], 0);
		offset += byteList[3]; 

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].serial_num[0], byteList[4], 1);
		offset += byteList[4]; 

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].drone_longtitude, byteList[5], 1);
		offset += byteList[5]; 

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].drone_latitude, byteList[6], 1);
		offset += byteList[6]; 

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].altitude, byteList[7], 1);
		offset += byteList[7]; 

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].height, byteList[8], 1);
		offset += byteList[8]; 

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].x_speed, byteList[9], 1);
		offset += byteList[9]; 

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].y_speed, byteList[10], 1);
		offset += byteList[10]; 

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].z_speed, byteList[11], 1);
		offset += byteList[11]; 

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].yaw_angle, byteList[12], 1);
		offset += byteList[12]; 

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].pilot_gps_clock, byteList[13], 1);
		offset += byteList[13]; 

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].pilot_latitude, byteList[14], 1);
		offset += byteList[14]; 

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].pilot_longitude, byteList[15], 1);
		offset += byteList[15]; 

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].home_longitude, byteList[16], 1);
		offset += byteList[16];

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].home_latitude, byteList[17], 1);
		offset += byteList[17]; 

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].product_type, byteList[18],0);
		offset += byteList[18]; 

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].uuid_len, byteList[19], 0);
		offset += byteList[19]; 

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].uuid[0], byteList[20], 1);
		offset += byteList[20];

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].zero_symbol, byteList[21], 0);
		offset += byteList[21];

		GetField(&decodeOut[offset], (uint8_t *)&droneID[num].crc, byteList[22], 1);
		offset += byteList[22];
	}
	else
	{
		; /* do nothing */
	}
}

/* Get the content of each field */
void GetField(uint8_t *src, uint8_t *dest, int8_t byteSize, int8_t isReorder)
{	
	int32_t ii = 0;

	if (isReorder)
	{   
		for (ii = 0; ii < byteSize; ii++)
		{
			memcpy((void *)dest, (void *)src, sizeof(uint8_t));
			dest++;
			src++;
		}
	}
	else
	{
	    dest += byteSize/2;
	 	for (ii = 0; ii < byteSize; ii++)
		{
			memcpy((void *)dest, (void *)src, sizeof(uint8_t));
			dest--; 
			src++;
		}
	}	
}


/* droneid crc check, CRC16 reversal look-up table */
bool DroneIdCrc16Check(uint8_t *decodeOut, DroneID_Signal_t *droneID)
{
	bool crc_check = false;
	int32_t idx = 0;
	uint8_t new_byte = 0;
	uint8_t crc_low = 0, crc_high = 0;
	uint16_t crc = 0x3692; /* CRC initial value 0x3692 */
	uint16_t temp_crc = 0;
	uint16_t table_idx = 0;
	uint16_t val = 0;

	for (idx = 0; idx < LENGTH_DECODE_CRC16; idx++)
	{
		new_byte = (uint8_t)(decodeOut[idx]);
		table_idx = (uint16_t)(crc ^ (uint16_t)(new_byte));
		table_idx &= 0xFF;
		val = g_crc16_table[table_idx];
		temp_crc = (uint16_t)(crc >> 8);
		crc = (uint16_t)(temp_crc ^ val);
	}
	crc_low = (uint8_t)(crc & 0xFF);
	crc_high = (uint8_t)((crc >> 8) & 0xFF);

	if (((crc_low == droneID->crc[1]) && (crc_high == droneID->crc[2])) ||
		(droneID->packet_type == 0x1003))
	{
		crc_check = true;
	}
	else
	{
		crc_check = false;
	}

	return crc_check;
}


/* droneid crc check, CRC24a */
bool DroneIdCrc24aCheck(uint8_t *decodeOut)
{
	bool crc_check = true;
	int32_t i = 0, j = 0;
	uint8_t decodeByte = 0;
	int32_t xorLen = LENGTH_DECODE_OUT_BIT;
	int32_t xorCutLen = 0;

	for (i = 0; i < LENGTH_CRC24A_POLY; i++)
	{
		g_crc24aPolyXorBit[i] = g_crc24aPoly[i];
	}

	/* transform decode byte to bit  */
	for (i = 0; i < LENGTH_DECODE_OUT_BYTE; i++)
	{
		for (j = 0; j < 8; j++)
		{
			decodeByte = g_decodeOut[i];
			g_decodeOutBit[i * 8 + j] = ((decodeByte >> (7 - j)) & 0x1);
		}
	}

	/* Modulo-2 Division  */
	for (i = 0; i < LENGTH_CRC24A_FOR_LOOP; i++)
	{
		xorLen -= xorCutLen;
		if (xorLen < LENGTH_CRC24A_POLY)
		{
			break;
		}
		memcpy(&g_decodeOutBit[0], &g_decodeOutBit[xorCutLen], xorLen);
		xorCutLen = 0;

		for (j = 0; j < xorLen; j++)
		{
			g_decodeOutBit[j] = g_decodeOutBit[j] ^ g_crc24aPolyXorBit[j];
		}
		for (j = 0; j < xorLen; j++)
		{
			if (g_decodeOutBit[j] == 0)
			{
				xorCutLen++;
			}
			else
			{
				break;
			}
		}
	}

	for (j = 0; j < xorLen; j++)
	{
		if (g_decodeOutBit[j] == 1)
		{
			crc_check = false;
		}
	}

	return crc_check;
}


/* droneid crc check, CRC24a look-up table */
bool DroneIdCrc24aTableCheck(uint8_t *decodeOut)
{
	bool crc_check = true;
	uint32_t i = 0u;
	uint8_t da = 0u, db = 0u;
	uint8_t crc_h = 0u;
	uint16_t crc_l = 0u;
	uint32_t crc_tmp = 0u;
	uint32_t crc_value = 0u;
	uint32_t crc_tab = 0u;
	uint32_t crc_out_b = 0u;

	for (i = 0; i < (LENGTH_DECODE_OUT_BYTE - 3); i++)
	{
		da = decodeOut[i];
		crc_h = (uint8_t)((crc_out_b >> 16) & 0xFF);
		crc_l = (uint16_t)(crc_out_b & 0xFFFF);
		db = (uint8_t)(da ^ crc_h);
		crc_tab = g_crc24a_table[db];
		crc_tmp = (uint32_t)(crc_l << 8);
		crc_out_b = (uint32_t)(crc_tmp ^ crc_tab);
	}

	crc_value = ((decodeOut[LENGTH_DECODE_OUT_BYTE - 3] << 16) |
				(decodeOut[LENGTH_DECODE_OUT_BYTE - 2] << 8) |
				(decodeOut[LENGTH_DECODE_OUT_BYTE - 1]));

	if (crc_out_b != crc_value)
	{
		crc_check = false;
	}

	return crc_check;
}


/* MIMO MRC */
void MimoMaxRatioComb(Cplxf_t *scBuff, Cplxf_t *scBuff2, Cplxf_t *dataScBuff)
{
	uint32_t symIdx = 0;
	uint32_t ii = 0;
	uint32_t offsetIn = 0;
	uint32_t offsetOut = 0;
	float square_chEst = 0.0f, square_chEst2 = 0.0f;
	float *normalized_factor = NULL;
	Cplxf_t rxDataTmp = { 0.0f }, rxDataTmp2 = { 0.0f };
	Cplxf_t *rxData = NULL, *rxData2 = NULL;
	Cplxf_t *chEst = NULL, *chEst2 = NULL;
	Cplxf_t *mimoOut = NULL;

	rxData = &g_rxData[0];
	rxData2 = &g_rxData2[0];
	chEst = &g_chEst[0];
	chEst2 = &g_chEst2[0];
	mimoOut = &g_mimoOutData[0];
	normalized_factor = &g_normalizedFactor[0];

	/* channel estimaiton using the 1st ZC seq. */
	memcpy((void*)&rxData[0],   (void*)&scBuff[3*SIZE_FFT + ((SIZE_FFT/2) - (NUM_DATA_CARRIER/2))], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	memcpy((void*)&rxData[300], (void*)&scBuff[3*SIZE_FFT + ((SIZE_FFT/2) + 1)], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	CalcChannelZcSnr(rxData, 0, g_zcSnr);
//	EstimateChannel(rxData, chEst);
	EstimateChannelLsDft(rxData, chEst, 0, LENGTH_STORE_PATCH);
	EstimatePhaseDiff(scBuff, chEst);

	/* channel estimaiton using the 2nd ZC seq. */
	memcpy((void*)&rxData2[0],   (void*)&scBuff2[3*SIZE_FFT + ((SIZE_FFT/2) - (NUM_DATA_CARRIER/2))], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	memcpy((void*)&rxData2[300], (void*)&scBuff2[3*SIZE_FFT + ((SIZE_FFT/2) + 1)], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	CalcChannelZcSnr(rxData2, 1, g_zcSnr);
//	EstimateChannel(rxData2, chEst2);
	EstimateChannelLsDft(rxData2, chEst2, 0, LENGTH_STORE_PATCH);
	EstimatePhaseDiff(scBuff2, chEst2);

	for (ii = 0; ii < NUM_DATA_CARRIER; ii++)
	{
		square_chEst  = chEst[ii].re*chEst[ii].re + chEst[ii].im*chEst[ii].im;
		square_chEst2 = chEst2[ii].re*chEst2[ii].re + chEst2[ii].im*chEst2[ii].im;
//		chEst[ii].re = chEst[ii].re / square_chEst;
//		chEst[ii].im = -chEst[ii].im / square_chEst;
//		chEst2[ii].re = chEst2[ii].re / square_chEst2;
//		chEst2[ii].im = -chEst2[ii].im / square_chEst2;
//		square_chEst = chEst[ii].re*chEst[ii].re + chEst[ii].im*chEst[ii].im;
//		square_chEst2 = chEst2[ii].re*chEst2[ii].re + chEst2[ii].im*chEst2[ii].im;
		normalized_factor[ii] = square_chEst + square_chEst2;
	}

	/* channel equalization for "valid" subcarrier data (i.e., 600 SCs) */
	for (symIdx = 0; symIdx < NUM_SYMBOL_PER_BURST; symIdx++)
	{
		if ((symIdx != 0) && (symIdx != 3) && (symIdx != 5))
		{
			/* Obtain the current symbol */
			memcpy((void*)&rxData[0],   (void*)&scBuff[offsetIn + ((SIZE_FFT/2) - (NUM_DATA_CARRIER/2))], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
			memcpy((void*)&rxData[300], (void*)&scBuff[offsetIn + ((SIZE_FFT/2) + 1)], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
			memcpy((void*)&rxData2[0],   (void*)&scBuff2[offsetIn + ((SIZE_FFT/2) - (NUM_DATA_CARRIER/2))], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
			memcpy((void*)&rxData2[300], (void*)&scBuff2[offsetIn + ((SIZE_FFT/2) + 1)], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));

			/* Do channel equalization */
			for (ii = 0; ii < NUM_DATA_CARRIER; ii++)
			{
				rxDataTmp = rxData[ii];
				rxDataTmp2 = rxData2[ii];
				mimoOut[ii].re = ((rxDataTmp.re * chEst[ii].re + rxDataTmp.im * chEst[ii].im) +
						(rxDataTmp2.re * chEst2[ii].re + rxDataTmp2.im * chEst2[ii].im)) / normalized_factor[ii];
				mimoOut[ii].im = ((-rxDataTmp.re * chEst[ii].im + rxDataTmp.im * chEst[ii].re) +
						(-rxDataTmp2.re * chEst2[ii].im + rxDataTmp2.im * chEst2[ii].re)) / normalized_factor[ii];
			}

			/* Output to data subcarrier buffer */
			memcpy((void*)&dataScBuff[offsetOut], (void*)mimoOut, NUM_DATA_CARRIER * sizeof(Cplxf_t));

			offsetOut = offsetOut + NUM_DATA_CARRIER;
		}

		offsetIn = offsetIn + SIZE_FFT;
	}
}

/* MIMO MRC, use LS DFT channel estimation for sym4 sym6 */
void MimoMaxRatioCombV1(Cplxf_t *scBuff, Cplxf_t *scBuff2, Cplxf_t *dataScBuff)
{
	uint32_t symIdx = 0;
	uint32_t ii = 0;
	uint32_t offsetIn = 0;
	uint32_t offsetOut = 0;
	float square_chEst = 0.0f, square_chEst2 = 0.0f;
	float *normalized_factor = NULL;
	float Pn[2] = { 0.0f };
	Cplxf_t rxDataTmp = { 0.0f }, rxDataTmp2 = { 0.0f };
	Cplxf_t *rxData = NULL, *rxData2 = NULL;
	Cplxf_t *chEstRx1 = NULL, *chEstRx2 = NULL;
	Cplxf_t *mimoOut = NULL;
	Cplxf_t *LS_Est4 = NULL, *LS_Est6 = NULL;
	Cplxf_t *LS_DFT_Est4 = NULL, *LS_DFT_Est5 = NULL, *LS_DFT_Est6 = NULL;

	rxData = &g_rxData[0];
	rxData2 = &g_rxData2[0];
	chEstRx1 = &g_chEst[0];
	chEstRx2 = &g_chEst2[0];
	LS_Est4 = &g_LS_Est4[0];
	LS_Est6 = &g_LS_Est6[0];
	LS_DFT_Est4 = &g_LS_DFT_Est4[0];
	LS_DFT_Est5 = &g_LS_DFT_Est5[0];
	LS_DFT_Est6 = &g_LS_DFT_Est6[0];
	mimoOut = &g_mimoOutData[0];
	normalized_factor = &g_normalizedFactor[0];

	/* antenna1, channel estimation using the 1st ZC seq, sym4 */
	memcpy((void*)&LS_Est4[0],   (void*)&scBuff[3*SIZE_FFT + ((SIZE_FFT/2) - (NUM_DATA_CARRIER/2))], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	memcpy((void*)&LS_Est4[300], (void*)&scBuff[3*SIZE_FFT + ((SIZE_FFT/2) + 1)], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	EstimateChannelLsDft(LS_Est4, LS_DFT_Est4, 0, LENGTH_STORE_PATCH);
	/* antenna1, channel estimation using the 2nd ZC seq, sym6 */
	memcpy((void*)&LS_Est6[0],   (void*)&scBuff[5*SIZE_FFT + ((SIZE_FFT/2) - (NUM_DATA_CARRIER/2))], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	memcpy((void*)&LS_Est6[300], (void*)&scBuff[5*SIZE_FFT + ((SIZE_FFT/2) + 1)], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	EstimateChannelLsDft(LS_Est6, LS_DFT_Est6, 1, LENGTH_STORE_PATCH);
	/* antenna1, estimate phase difference of each OFDM symbol (caused by residual CFO) */
	EstimatePhaseDiffCompAllSym(scBuff, LS_DFT_Est4, LS_DFT_Est6, LS_DFT_Est5);
	CalcFreqDomainSnr(LS_Est4, LS_DFT_Est5, 0, Pn, g_zcSnr);
	memcpy((void*)&chEstRx1[0], (void*)&LS_DFT_Est5[0], sizeof(Cplxf_t) * NUM_DATA_CARRIER);

	/* antenna2, channel estimation using the 1st ZC seq, sym4 */
	memcpy((void*)&LS_Est4[0],   (void*)&scBuff2[3*SIZE_FFT + ((SIZE_FFT/2) - (NUM_DATA_CARRIER/2))], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	memcpy((void*)&LS_Est4[300], (void*)&scBuff2[3*SIZE_FFT + ((SIZE_FFT/2) + 1)], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	EstimateChannelLsDft(LS_Est4, LS_DFT_Est4, 0, LENGTH_STORE_PATCH);
	/* antenna2, channel estimation using the 2nd ZC seq, sym6 */
	memcpy((void*)&LS_Est6[0],   (void*)&scBuff2[5*SIZE_FFT + ((SIZE_FFT/2) - (NUM_DATA_CARRIER/2))], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	memcpy((void*)&LS_Est6[300], (void*)&scBuff2[5*SIZE_FFT + ((SIZE_FFT/2) + 1)], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	EstimateChannelLsDft(LS_Est6, LS_DFT_Est6, 1, LENGTH_STORE_PATCH);
	/* antenna2, estimate phase difference of each OFDM symbol (caused by residual CFO) */
	EstimatePhaseDiffCompAllSym(scBuff2, LS_DFT_Est4, LS_DFT_Est6, LS_DFT_Est5);
	CalcFreqDomainSnr(LS_Est4, LS_DFT_Est5, 1, Pn, g_zcSnr);
	memcpy((void*)&chEstRx2[0], (void*)&LS_DFT_Est5[0], sizeof(Cplxf_t) * NUM_DATA_CARRIER);

	/* normalized_factor = Ph_Rx1/Pn(1) + Ph_Rx2/Pn(2); */
	for (ii = 0; ii < NUM_DATA_CARRIER; ii++)
	{
		square_chEst  = chEstRx1[ii].re*chEstRx1[ii].re + chEstRx1[ii].im*chEstRx1[ii].im;
		square_chEst2 = chEstRx2[ii].re*chEstRx2[ii].re + chEstRx2[ii].im*chEstRx2[ii].im;
		normalized_factor[ii] = (square_chEst / Pn[0]) + (square_chEst2 / Pn[1]);
	}

	/* channel equalization for "valid" subcarrier data (i.e., 600 SCs) */
	for (symIdx = 0; symIdx < NUM_SYMBOL_PER_BURST; symIdx++)
	{
		if ((symIdx != 0) && (symIdx != 3) && (symIdx != 5))
		{
			/* Obtain the current symbol */
			memcpy((void*)&rxData[0],   (void*)&scBuff[offsetIn + ((SIZE_FFT/2) - (NUM_DATA_CARRIER/2))], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
			memcpy((void*)&rxData[300], (void*)&scBuff[offsetIn + ((SIZE_FFT/2) + 1)], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
			memcpy((void*)&rxData2[0],   (void*)&scBuff2[offsetIn + ((SIZE_FFT/2) - (NUM_DATA_CARRIER/2))], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
			memcpy((void*)&rxData2[300], (void*)&scBuff2[offsetIn + ((SIZE_FFT/2) + 1)], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));

			/* Do channel equalization */
			for (ii = 0; ii < NUM_DATA_CARRIER; ii++)
			{
				rxDataTmp = rxData[ii];
				rxDataTmp2 = rxData2[ii];
				mimoOut[ii].re = ((rxDataTmp.re * chEstRx1[ii].re + rxDataTmp.im * chEstRx1[ii].im) / Pn[0] +
						(rxDataTmp2.re * chEstRx2[ii].re + rxDataTmp2.im * chEstRx2[ii].im) / Pn[1]) / normalized_factor[ii];
				mimoOut[ii].im = ((-rxDataTmp.re * chEstRx1[ii].im + rxDataTmp.im * chEstRx1[ii].re) / Pn[0] +
						(-rxDataTmp2.re * chEstRx2[ii].im + rxDataTmp2.im * chEstRx2[ii].re) / Pn[1]) / normalized_factor[ii];
			}

			/* Output to data subcarrier buffer */
			memcpy((void*)&dataScBuff[offsetOut], (void*)mimoOut, NUM_DATA_CARRIER * sizeof(Cplxf_t));

			offsetOut = offsetOut + NUM_DATA_CARRIER;
		}

		offsetIn = offsetIn + SIZE_FFT;
	}
}


/* calculate EVM */
void CalcEvm(Cplxf_t *dataScBuff, float *evm)
{
	uint32_t ii = 0;
	uint32_t validCnt = 0;
	float angle = 0.0f;
	float absSubRe = 0.0f, absSubIm = 0.0f;
	float powerSum = 0.0f, powerMean = 0.0f;

	for (ii = 0; ii < LENGTH_DATA_CARRIER_BUFF; ii++)
	{
		angle = atan2f(dataScBuff[ii].im, dataScBuff[ii].re);
		if ((angle > 0) && (angle < HALF_PI_VALUE))
		{
			absSubRe = fabsf(dataScBuff[ii].re - INV_SQRT_2);
			absSubIm = fabsf(dataScBuff[ii].im - INV_SQRT_2);
			powerSum += absSubRe * absSubRe + absSubIm * absSubIm;
			validCnt++;
		}
	}
	powerMean = powerSum / validCnt;
	*evm = sqrtf(powerMean) * 100;
}


void DSPF_sp_PL_fftSPxSP_cn(float* g_x_sp, float* g_y_sp)
{
	if (m_dma_fft_cb != NULL)
		m_dma_fft_cb(g_x_sp, g_y_sp);
}


/* LS DFT channel estimation */
void EstimateChannelLsDft(Cplxf_t *rxData, Cplxf_t *chEst, uint32_t zcIdx, uint32_t storePathLen)
{
	uint32_t ii = 0;
	uint32_t powHtMaxIdx = 0;
	uint32_t storeIdx = 0;
	float invNormSquare = 0.0f;
	float powHt = 0.0f, powHtMax = 0.0f;
	Cplxf_t H_LsTmp[NUM_DATA_CARRIER] = { { 0.0f } };
	float *H_LsTmp2048 = NULL;
	float *H_LsTmp2048_fft = NULL;
	Cplxf_t *Ht = NULL;
	float *Ht_DFT = NULL;
	float *Hk_DFT2048 = NULL;
	Cplxf_t *Hk_DFT600 = NULL;
	Cplxf_t *Ht_in_out = NULL;
	Cplxf_t *Ht_DFT_in_out = NULL;
	Cplxf_t *H_LS600 = NULL;

	H_LsTmp2048 = &g_Ht_in_sp[0];
	H_LsTmp2048_fft = &g_Ht_out_sp[0];
	Ht = &g_Ht[0];
	Ht_DFT = &g_Hk_in_sp[0];
	Hk_DFT2048 = &g_Hk_out_sp[0];
	Hk_DFT600 = &chEst[0];
	Ht_in_out = &g_Ht_in_out[0];
	Ht_DFT_in_out = &g_Ht_DFT_in_out[0];
	H_LS600 = &rxData[0];

	memset((void *)H_LsTmp2048, 0, SIZE_FFT * sizeof(Cplxf_t));
	memset((void *)Ht_DFT, 0, SIZE_FFT * sizeof(Cplxf_t));
	memset((void *)Ht_in_out, 0, SIZE_FFT * sizeof(Cplxf_t));
	memset((void *)Ht_DFT_in_out, 0, SIZE_FFT * sizeof(Cplxf_t));

	for (ii = 0; ii < NUM_DATA_CARRIER; ii++)
	{
		invNormSquare = 1.0 / (g_zcData[zcIdx][ii].re*g_zcData[zcIdx][ii].re + g_zcData[zcIdx][ii].im*g_zcData[zcIdx][ii].im);

		H_LsTmp[ii].re =  rxData[ii].re*g_zcData[zcIdx][ii].re + rxData[ii].im*g_zcData[zcIdx][ii].im;
		H_LsTmp[ii].im = -rxData[ii].re*g_zcData[zcIdx][ii].im + rxData[ii].im*g_zcData[zcIdx][ii].re;
		H_LsTmp[ii].re = H_LsTmp[ii].re * invNormSquare;
		H_LsTmp[ii].im = H_LsTmp[ii].im * invNormSquare;
		H_LS600[ii].re = H_LsTmp[ii].re;
		H_LS600[ii].im = H_LsTmp[ii].im;
	}

if(flag_debug_fft_dma)
{
	for (ii = 0; ii < (NUM_DATA_CARRIER / 2); ii++)
	{	/* front 300 subcarrier cplxf type data, conj(H_LsTmp[0:299]) */
		H_LsTmp2048[SIZE_FFT - 2*300 + 2*ii]     = H_LsTmp[ii].re;
		H_LsTmp2048[SIZE_FFT - 2*300 + 2*ii + 1] = -H_LsTmp[ii].im;
		/* rear 300 subcarrier cplxf type data, conj(H_LsTmp[300:599]) */
		H_LsTmp2048[SIZE_FFT + 2 + 2*ii]         = H_LsTmp[ii + NUM_DATA_CARRIER / 2 ].re;
		H_LsTmp2048[SIZE_FFT + 2 + 2*ii + 1]     = -H_LsTmp[ii + NUM_DATA_CARRIER / 2].im;
	}
	/* conj(fft(conj(H_LsTmp))) / fft_size */
	DSPF_sp_PL_fftSPxSP_cn(H_LsTmp2048, H_LsTmp2048_fft);
	for (ii = 0; ii < SIZE_FFT; ii++)
	{
		Ht[ii].re = H_LsTmp2048_fft[2*ii] / SIZE_FFT;
		Ht[ii].im = -H_LsTmp2048_fft[2*ii + 1] / SIZE_FFT;
		powHt = Ht[ii].re * Ht[ii].re + Ht[ii].im * Ht[ii].im;
		if (powHt > powHtMax)
		{
			powHtMax = powHt;
			powHtMaxIdx = ii;
		}
	}
	for (ii = 0; ii < (2 * storePathLen + 1); ii++)
	{
		storeIdx = ((powHtMaxIdx - storePathLen + ii + 1) % SIZE_FFT);
		Ht_DFT[2 * storeIdx] = Ht[storeIdx].re;
		Ht_DFT[2 * storeIdx + 1] = Ht[storeIdx].im;
	}
	DSPF_sp_PL_fftSPxSP_cn(Ht_DFT, Hk_DFT2048);
	for (ii = 0; ii < (NUM_DATA_CARRIER / 2); ii++)
	{
		Hk_DFT600[ii].re = Hk_DFT2048[SIZE_FFT - 2*300 + 2*ii];
		Hk_DFT600[ii].im = Hk_DFT2048[SIZE_FFT - 2*300 + 2*ii + 1];
		Hk_DFT600[ii + NUM_DATA_CARRIER / 2].re = Hk_DFT2048[SIZE_FFT + 2 + 2*ii];
		Hk_DFT600[ii + NUM_DATA_CARRIER / 2].im = Hk_DFT2048[SIZE_FFT + 2 + 2*ii + 1];
	}
} else {
	for (ii = 0; ii < (NUM_DATA_CARRIER / 2); ii++)
	{	/* front 300 subcarrier cplxf type data, conj(H_LsTmp[0:299]) */
		Ht_in_out[SIZE_FFT/2 - 300 + ii].re = H_LsTmp[ii].re;
		Ht_in_out[SIZE_FFT/2 - 300 + ii].im = -H_LsTmp[ii].im;
		/* rear 300 subcarrier cplxf type data, conj(H_LsTmp[300:599]) */
		Ht_in_out[SIZE_FFT/2 + 1 + ii].re = H_LsTmp[ii + NUM_DATA_CARRIER / 2 ].re;
		Ht_in_out[SIZE_FFT/2 + 1 + ii].im = -H_LsTmp[ii + NUM_DATA_CARRIER / 2].im;
	}
	/* conj(fft(conj(H_LsTmp))) / fft_size */
	fft(Ht_in_out, SIZE_FFT);
	for (ii = 0; ii < SIZE_FFT; ii++)
	{
		Ht[ii].re = Ht_in_out[ii].re / SIZE_FFT;
		Ht[ii].im = -Ht_in_out[ii].im / SIZE_FFT;
		powHt = Ht[ii].re * Ht[ii].re + Ht[ii].im * Ht[ii].im;
		if (powHt > powHtMax)
		{
			powHtMax = powHt;
			powHtMaxIdx = ii;
		}
	}
	for (ii = 0; ii < (2 * storePathLen + 1); ii++)
	{
		storeIdx = ((powHtMaxIdx - storePathLen + ii + 1) % SIZE_FFT);
		Ht_DFT_in_out[storeIdx].re = Ht[storeIdx].re;
		Ht_DFT_in_out[storeIdx].im = Ht[storeIdx].im;
	}
	fft(Ht_DFT_in_out, SIZE_FFT);
	for (ii = 0; ii < (NUM_DATA_CARRIER / 2); ii++)
	{
		Hk_DFT600[ii].re = Ht_DFT_in_out[SIZE_FFT/2 - 300 + ii].re;
		Hk_DFT600[ii].im = Ht_DFT_in_out[SIZE_FFT/2 - 300 + ii].im;
		Hk_DFT600[ii + NUM_DATA_CARRIER / 2].re = Ht_DFT_in_out[SIZE_FFT/2 + 1 + ii].re;
		Hk_DFT600[ii + NUM_DATA_CARRIER / 2].im = Ht_DFT_in_out[SIZE_FFT/2 + 1 + ii].im;
	}
}
}


/* estimate phase diffrence of each OFDM symbol */
void EstimatePhaseDiff(Cplxf_t *scBuff, Cplxf_t *chEst4)
{
	int32_t ii = 0, jj = 0;
	Cplxf_t *RxZcSym6Freq = NULL;
	Cplxf_t *LS_DFT_Est4 = NULL;
	Cplxf_t *ZcSym6Freq = NULL;
	Cplxf_t RxZcSym6FreqMulEst4[NUM_DATA_CARRIER] = { { 0.0f } };
	Cplxf_t Sym6PhaseDiffCorr = { 0.0f };
	Cplxf_t Sym6PhaseDiffCorrTmp = { 0.0f };
	Cplxf_t *freq_domain_symbols = NULL;
	Cplxf_t freq_domain_symbols_tmp = { 0.0f };
	float Sym6PhaseDiff = 0.0f, K = 0.0f;
	float PhaseDiff[NUM_SYMBOL_PER_BURST - 1] = { 0.0f };
	float PhaseDiff_cosf = 0.0f;
	float PhaseDiff_sinf = 0.0f;

	RxZcSym6Freq = &g_rxData[0];
	LS_DFT_Est4 = &chEst4[0];
	ZcSym6Freq = &g_zcData[1][0];

	memcpy((void*)&RxZcSym6Freq[0],   (void*)&scBuff[5*SIZE_FFT + ((SIZE_FFT/2) - (NUM_DATA_CARRIER/2))], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	memcpy((void*)&RxZcSym6Freq[300], (void*)&scBuff[5*SIZE_FFT + ((SIZE_FFT/2) + 1)], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));

	/* Sym6PhaseDiff = angle(RxZcSym6Freq .* conj(LS_DFT_Est4) * ZcSym6Freq') */
	for (ii = 0; ii < NUM_DATA_CARRIER; ii++)
	{	/* RxZcSym6Freq .* conj(LS_DFT_Est4) */
		RxZcSym6FreqMulEst4[ii].re =  RxZcSym6Freq[ii].re * LS_DFT_Est4[ii].re + RxZcSym6Freq[ii].im * LS_DFT_Est4[ii].im;
		RxZcSym6FreqMulEst4[ii].im = -RxZcSym6Freq[ii].re * LS_DFT_Est4[ii].im + RxZcSym6Freq[ii].im * LS_DFT_Est4[ii].re;
		/* RxZcSym6FreqMulEst4 * ZcSym6Freq' = sum(RxZcSym6FreqMulEst4 .* conj(ZcSym6Freq)) */
		Sym6PhaseDiffCorrTmp.re =  RxZcSym6FreqMulEst4[ii].re * ZcSym6Freq[ii].re + RxZcSym6FreqMulEst4[ii].im * ZcSym6Freq[ii].im;
		Sym6PhaseDiffCorrTmp.im = -RxZcSym6FreqMulEst4[ii].re * ZcSym6Freq[ii].im + RxZcSym6FreqMulEst4[ii].im * ZcSym6Freq[ii].re;
		Sym6PhaseDiffCorr.re += Sym6PhaseDiffCorrTmp.re;
		Sym6PhaseDiffCorr.im += Sym6PhaseDiffCorrTmp.im;
	}
	Sym6PhaseDiff = atan2f(Sym6PhaseDiffCorr.im, Sym6PhaseDiffCorr.re);
	K = Sym6PhaseDiff / 2;

	for (ii = 0; ii < (NUM_SYMBOL_PER_BURST - 1); ii++)
	{
		PhaseDiff[ii] = K * (ii - 2);
	}

	for (ii = 0; ii < (NUM_SYMBOL_PER_BURST - 1); ii++)
	{
		freq_domain_symbols = &scBuff[(ii + 1) * SIZE_FFT];
		PhaseDiff_cosf = cosf(-PhaseDiff[ii]);
		PhaseDiff_sinf = sinf(-PhaseDiff[ii]);
		for (jj = 0; jj < SIZE_FFT; jj++)
		{
			freq_domain_symbols_tmp = freq_domain_symbols[jj];
			freq_domain_symbols[jj].re = PhaseDiff_cosf * freq_domain_symbols_tmp.re - PhaseDiff_sinf * freq_domain_symbols_tmp.im;
			freq_domain_symbols[jj].im = PhaseDiff_cosf * freq_domain_symbols_tmp.im + PhaseDiff_sinf * freq_domain_symbols_tmp.re;
		}
	}
}

/* estimate phase diffrence of each OFDM symbol, add compensate all symbol */
void EstimatePhaseDiffCompAllSym(Cplxf_t *scBuff, Cplxf_t *chEst4, Cplxf_t *chEst6, Cplxf_t *chEst5)
{
	int32_t ii = 0, jj = 0;
	Cplxf_t *RxZcSym6Freq = NULL;
	Cplxf_t *LS_DFT_Est4 = NULL;
	Cplxf_t *ZcSym6Freq = NULL;
	Cplxf_t RxZcSym6FreqMulEst4[NUM_DATA_CARRIER] = { { 0.0f } };
	Cplxf_t Sym6PhaseDiffCorr = { 0.0f };
	Cplxf_t Sym6PhaseDiffCorrTmp = { 0.0f };
	Cplxf_t *freq_domain_symbols = NULL;
	Cplxf_t freq_domain_symbols_tmp = { 0.0f };
	Cplxf_t chEst6_tmp = { 0.0f };
	float Sym6PhaseDiff = 0.0f, K = 0.0f;
	float PhaseDiff[NUM_SYMBOL_PER_BURST - 1] = { 0.0f };
	float PhaseDiff_cosf = 0.0f;
	float PhaseDiff_sinf = 0.0f;

	RxZcSym6Freq = &g_rxData[0];
	LS_DFT_Est4 = &chEst4[0];
	ZcSym6Freq = &g_zcData[1][0];

	memcpy((void*)&RxZcSym6Freq[0],   (void*)&scBuff[5*SIZE_FFT + ((SIZE_FFT/2) - (NUM_DATA_CARRIER/2))], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));
	memcpy((void*)&RxZcSym6Freq[300], (void*)&scBuff[5*SIZE_FFT + ((SIZE_FFT/2) + 1)], (NUM_DATA_CARRIER/2)*sizeof(Cplxf_t));

	/* Sym6PhaseDiff = angle(RxZcSym6Freq .* conj(LS_DFT_Est4) * ZcSym6Freq') */
	for (ii = 0; ii < NUM_DATA_CARRIER; ii++)
	{	/* RxZcSym6Freq .* conj(LS_DFT_Est4) */
		RxZcSym6FreqMulEst4[ii].re =  RxZcSym6Freq[ii].re * LS_DFT_Est4[ii].re + RxZcSym6Freq[ii].im * LS_DFT_Est4[ii].im;
		RxZcSym6FreqMulEst4[ii].im = -RxZcSym6Freq[ii].re * LS_DFT_Est4[ii].im + RxZcSym6Freq[ii].im * LS_DFT_Est4[ii].re;
		/* RxZcSym6FreqMulEst4 * ZcSym6Freq' = sum(RxZcSym6FreqMulEst4 .* conj(ZcSym6Freq)) */
		Sym6PhaseDiffCorrTmp.re =  RxZcSym6FreqMulEst4[ii].re * ZcSym6Freq[ii].re + RxZcSym6FreqMulEst4[ii].im * ZcSym6Freq[ii].im;
		Sym6PhaseDiffCorrTmp.im = -RxZcSym6FreqMulEst4[ii].re * ZcSym6Freq[ii].im + RxZcSym6FreqMulEst4[ii].im * ZcSym6Freq[ii].re;
		Sym6PhaseDiffCorr.re += Sym6PhaseDiffCorrTmp.re;
		Sym6PhaseDiffCorr.im += Sym6PhaseDiffCorrTmp.im;
	}
	Sym6PhaseDiff = atan2f(Sym6PhaseDiffCorr.im, Sym6PhaseDiffCorr.re);
	K = Sym6PhaseDiff / 2;

	/* PhaseDiff = K * ([2:9] - 4); */
	for (ii = 0; ii < (NUM_SYMBOL_PER_BURST - 1); ii++)
	{
		PhaseDiff[ii] = K * (ii - 2);
	}

	/* freq_domain_symbols(2:end,:) = diag(exp(-j*PhaseDiff)) * freq_domain_symbols(2:end,:); */
	for (ii = 0; ii < (NUM_SYMBOL_PER_BURST - 1); ii++)
	{
		freq_domain_symbols = &scBuff[(ii + 1) * SIZE_FFT];
		PhaseDiff_cosf = cosf(-PhaseDiff[ii]);
		PhaseDiff_sinf = sinf(-PhaseDiff[ii]);
		for (jj = 0; jj < SIZE_FFT; jj++)
		{
			freq_domain_symbols_tmp = freq_domain_symbols[jj];
			freq_domain_symbols[jj].re = PhaseDiff_cosf * freq_domain_symbols_tmp.re - PhaseDiff_sinf * freq_domain_symbols_tmp.im;
			freq_domain_symbols[jj].im = PhaseDiff_cosf * freq_domain_symbols_tmp.im + PhaseDiff_sinf * freq_domain_symbols_tmp.re;
		}
	}

	/* LS_DFT_Est6 = exp(-1j*PhaseDiff(5)) * LS_DFT_Est6; */
	for (ii = 0; ii < NUM_DATA_CARRIER; ii++)
	{
		chEst6_tmp.re = chEst6[ii].re;
		chEst6_tmp.im = chEst6[ii].im;
		PhaseDiff_cosf = cosf(-PhaseDiff[4]);
		PhaseDiff_sinf = sinf(-PhaseDiff[4]);
		chEst6[ii].re = PhaseDiff_cosf * chEst6_tmp.re - PhaseDiff_sinf * chEst6_tmp.im;
		chEst6[ii].im = PhaseDiff_cosf * chEst6_tmp.im + PhaseDiff_sinf * chEst6_tmp.re;
		chEst5[ii].re = (chEst4[ii].re + chEst6[ii].re) / 2;
		chEst5[ii].im = (chEst4[ii].im + chEst6[ii].im) / 2;
	}
}


/* Calculate SNR in frequency domain */
void CalcFreqDomainSnr(Cplxf_t *rxData, Cplxf_t *chEst5, int32_t rxIdx, float *pPn, float *pSnr)
{
	uint32_t ii = 0;
	float Pn = 0.0f, Pn_dB = 0.0f;
	float RSRP_Liner =  0.0f , RSRP_dB = 0.0f;
	Cplxf_t chEst_sub[NUM_DATA_CARRIER] = { { 0.0f } };

	for (ii = 0; ii < NUM_DATA_CARRIER; ii++)
	{
		chEst_sub[ii].re = rxData[ii].re - chEst5[ii].re;
		chEst_sub[ii].im = rxData[ii].im - chEst5[ii].im;
		RSRP_Liner += (chEst5[ii].re * chEst5[ii].re + chEst5[ii].im * chEst5[ii].im);
	}
	Pn = CalcCplxfVectorVar(chEst_sub, NUM_DATA_CARRIER);
	Pn_dB = 10 * log10f(Pn);

	RSRP_Liner /= NUM_DATA_CARRIER;
	RSRP_dB= 10 * log10f(RSRP_Liner);

	pPn[rxIdx] = Pn;
	pSnr[rxIdx] = RSRP_dB - Pn_dB;
}

